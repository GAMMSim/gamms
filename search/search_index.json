{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"agent/","title":"Agent Engine","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing the engine that manages agents.</p> <p>The engine is responsible for creating, managing, and terminating agents, as well as facilitating interactions between them.</p>"},{"location":"agent/#gamms.typing.IAgentEngine.create_agent","title":"<code>create_agent(start_node_id, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Instantiate a new agent within the engine.</p> <p>Parameters:</p> Name Type Description Default <code>start_node_id</code> <code>int</code> <p>The identifier for the starting node or position of the agent.</p> required <code>**kwargs</code> <p>Additional keyword arguments for agent initialization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>IAgent</code> <code>IAgent</code> <p>The newly created agent instance.</p>"},{"location":"agent/#gamms.typing.IAgentEngine.create_iter","title":"<code>create_iter()</code>  <code>abstractmethod</code>","text":"<p>Create an iterator for processing agent steps.</p> <p>Returns:</p> Type Description <code>Iterable[IAgent]</code> <p>Iterable[IAgent]: An iterator object over all agents.</p>"},{"location":"agent/#gamms.typing.IAgentEngine.delete_agent","title":"<code>delete_agent(name)</code>  <code>abstractmethod</code>","text":"<p>Delete an agent by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the agent to retrieve.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no agent with the specified name exists.</p>"},{"location":"agent/#gamms.typing.IAgentEngine.get_agent","title":"<code>get_agent(name)</code>  <code>abstractmethod</code>","text":"<p>Retrieve an agent by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the agent to retrieve.</p> required <p>Returns:</p> Name Type Description <code>IAgent</code> <code>IAgent</code> <p>The agent instance corresponding to the provided name.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no agent with the specified name exists.</p>"},{"location":"agent/#gamms.typing.IAgentEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the agent engine and perform necessary cleanup operations.</p> <p>This method should ensure that all resources are properly released and that agents are gracefully shut down.</p>"},{"location":"agent/#agent","title":"Agent","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing an agent in the system.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name identifier for the agent.</p>"},{"location":"agent/#gamms.typing.IAgent.get_state","title":"<code>get_state()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the current state of the agent.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The current state data of the agent, structure depends on implementation.</p>"},{"location":"agent/#gamms.typing.IAgent.register_sensor","title":"<code>register_sensor(name, sensor)</code>  <code>abstractmethod</code>","text":"<p>Register a sensor with the agent.</p> <p>Sensors can be used by the agent to perceive the environment or gather data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier for the sensor.</p> required <code>sensor</code> <code>ISensor</code> <p>The sensor instance or object to be registered.</p> required"},{"location":"agent/#gamms.typing.IAgent.register_strategy","title":"<code>register_strategy(strategy)</code>  <code>abstractmethod</code>","text":"<p>Register a strategy with the agent.</p> <p>Strategies define the decision-making or action-planning mechanisms for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Callable[[Dict[str, Any]], None]</code> <p>The strategy instance or object to be registered.</p> required"},{"location":"agent/#gamms.typing.IAgent.set_state","title":"<code>set_state(state)</code>  <code>abstractmethod</code>","text":"<p>Update the agent's state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Dict[str, Any]</code> <p>The new state data to set for the agent.</p> required"},{"location":"agent/#gamms.typing.IAgent.step","title":"<code>step()</code>  <code>abstractmethod</code>","text":"<p>Execute a single operational step of the agent.</p> <p>This method should contain the logic that defines the agent's behavior during one iteration or time step in the system.</p>"},{"location":"agent_state_addition/","title":"Passing Extra Information to Agent States in GAMMS","text":""},{"location":"agent_state_addition/#introduction","title":"Introduction","text":"<p>GAMMS allows you to pass custom information to agents via their state. This feature is particularly useful for enhancing agent strategies with contextual or dynamic data. In this guide, you'll learn how to: 1. Add extra information to an agent's state. 2. Use that information in the agent's strategy. 3. Dynamically update state information during the simulation.</p>"},{"location":"agent_state_addition/#adding-extra-information-to-agent-state","title":"Adding Extra Information to Agent State","text":"<p>You can pass custom variables to an agent's state by using the <code>state.update()</code> method. This can be done during each simulation step. This information can then be accessed to create your strategy.</p>"},{"location":"agent_state_addition/#example-adding-custom-variables-to-state","title":"Example: Adding Custom Variables to State","text":"<pre><code>for agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Add custom variables to the agent's state\n    state.update({\n        \"food_positions\": [food['x'] for food in remaining_food],  # Node IDs of food\n        \"agent_params\": {\"speed\": 5, \"energy\": 100},               # Custom parameters\n        \"flag_positions\": FLAG_POSITIONS,                         # Example static data\n    })\n\n    # Execute the agent's strategy\n    agent.strategy(state)\n\n    # Update the state back to the agent\n    agent.set_state()\n</code></pre>"},{"location":"agent_state_addition/#dynamically-updating-state-information","title":"Dynamically Updating State Information","text":"<p>State information can also be updated dynamically during the simulation. For example, you might want to update a variable based on changes in the environment.</p>"},{"location":"agent_state_addition/#example-updating-state-based-on-agent-interaction","title":"Example: Updating State Based on Agent Interaction","text":"<pre><code>for agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Example: Update energy level based on movement\n    if state['action']:\n        state['agent_params']['energy'] -= 1\n\n    # Example: Remove a food position if the agent reaches it\n    if state['curr_pos'] in state['food_positions']:\n        state['food_positions'].remove(state['curr_pos'])\n\n    # Execute the agent's strategy\n    agent.strategy(state)\n\n    # Update the state back to the agent\n    agent.set_state()\n</code></pre>"},{"location":"agent_state_addition/#handling-initialization-of-custom-state-variables","title":"Handling Initialization of Custom State Variables","text":"<p>To ensure custom state variables are initialized properly, you can set them during the simulation startup or the first simulation step.</p>"},{"location":"agent_state_addition/#example-initializing-state-variables","title":"Example: Initializing State Variables","text":"<pre><code>for agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Initialize custom variables if they don't exist\n    if 'memory' not in state:\n        state['memory'] = {}  # Initialize memory for tracking visited nodes\n\n    agent.set_state()\n</code></pre>"},{"location":"agent_state_addition/#advanced-use-case-sharing-global-data","title":"Advanced Use Case: Sharing Global Data","text":"<p>Sometimes you might want agents to share global information, such as environmental conditions or the positions of other agents.</p>"},{"location":"agent_state_addition/#example-sharing-global-data-among-agents","title":"Example: Sharing Global Data Among Agents","text":"<pre><code>global_data = {\n    \"temperature\": 25,\n    \"wind_speed\": 10,\n    \"food_locations\": [0, 1, 2, 3],\n}\n\nfor agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Share global data with agents\n    state.update(global_data)\n\n    agent.strategy(state)\n    agent.set_state()\n</code></pre>"},{"location":"artists/","title":"Using Artists in GAMMS","text":""},{"location":"artists/#introduction","title":"Introduction","text":"<p>In GAMMS, artists are visual elements that can be added to the simulation to enhance visualization. They are typically used to represent objects like resources, obstacles, or any custom markers. This guide explains how to create, customize, and use artists in your GAMMS simulations.</p>"},{"location":"artists/#creating-an-artist","title":"Creating an Artist","text":"<p>Artists are added using the <code>ctx.visual.add_artist()</code> method. This requires you to define: 1. Name: A unique identifier for the artist. 2. Data: A dictionary containing the artist's properties (e.g., position, color, size).</p>"},{"location":"artists/#example-adding-a-circle-artist","title":"Example: Adding a Circle Artist","text":"<p>The following example creates a circle artist to represent a resource on the graph:</p> <pre><code># Define the data for the circle artist\ncircle_data = {\n    'x': 100,            # X-coordinate\n    'y': 200,            # Y-coordinate\n    'scale': 15.0,       # Radius of the circle\n    'color': (255, 0, 0) # RGB color (red)\n}\n\n# Add the circle artist to the visualization\nctx.visual.add_artist('resource_node', circle_data)\n</code></pre>"},{"location":"artists/#updating-artists-dynamically","title":"Updating Artists Dynamically","text":"<p>Artists can be updated dynamically during the simulation to reflect changes in the environment. For example, you can move a circle to a new position or change its color.</p>"},{"location":"artists/#example-updating-an-artists-position","title":"Example: Updating an Artist's Position","text":"<pre><code># Update the position of an artist\ncircle_data['x'] = 150  # New X-coordinate\ncircle_data['y'] = 250  # New Y-coordinate\n\n# Re-add or update the artist\nctx.visual.add_artist('resource_node', circle_data)\n</code></pre>"},{"location":"artists/#removing-an-artist","title":"Removing an Artist","text":"<p>To remove an artist, use the <code>ctx.visual.remove_artist()</code> method with the name of the artist:</p> <pre><code># Remove the circle artist\nctx.visual.remove_artist('resource_node')\n</code></pre>"},{"location":"artists/#customizing-artists","title":"Customizing Artists","text":"<p>Artists can be customized with additional properties to represent various objects in the simulation. Below are some common customizations:</p> <ol> <li>Shape:</li> <li> <p>Circles (<code>pygame.draw.circle</code>) are the default, but you can create custom shapes by extending the artist logic.</p> </li> <li> <p>Color:</p> </li> <li> <p>Use RGB tuples like <code>(255, 0, 0)</code> for red, <code>(0, 255, 0)</code> for green, etc.</p> </li> <li> <p>Size:</p> </li> <li> <p>The <code>scale</code> property defines the size of the artist (e.g., the radius of a circle).</p> </li> <li> <p>Dynamic Properties:</p> </li> <li>Pass any extra data into the <code>data</code> dictionary for custom rendering logic.</li> </ol>"},{"location":"artists/#advanced-example-highlighting-nodes-dynamically","title":"Advanced Example: Highlighting Nodes Dynamically","text":"<p>In this example, we use artists to highlight nodes as agents visit them:</p> <pre><code>visited_nodes = set()\n\nwhile not ctx.is_terminated():\n    for agent in ctx.agent.create_iter():\n        current_node = agent.current_node_id\n        if current_node not in visited_nodes:\n            visited_nodes.add(current_node)\n\n            # Create a circle to highlight the visited node\n            highlight_data = {\n                'x': ctx.graph.graph.get_node(current_node).x,\n                'y': ctx.graph.graph.get_node(current_node).y,\n                'scale': 10.0,\n                'color': (0, 255, 0)  # Green color for visited nodes\n            }\n            ctx.visual.add_artist(f'visited_node_{current_node}', highlight_data)\n</code></pre>"},{"location":"context/","title":"GAMMS Context","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing the overall context of the system.</p> <p>The <code>IContext</code> interface serves as a central point of access to various engine components within the system, including sensors, visualization, agents, and graph management. It provides properties to retrieve instances of these engines, facilitating coordinated interactions and data flow between different system parts.</p>"},{"location":"context/#gamms.typing.IContext.agent","title":"<code>agent</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the agent engine.</p> <p>The agent engine manages the lifecycle and behavior of agents within the system. It handles agent creation, state management, and interaction with other system components.</p> <p>Returns:</p> Name Type Description <code>IAgentEngine</code> <code>IAgentEngine</code> <p>An instance of the agent engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the agent engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.graph","title":"<code>graph</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the graph engine.</p> <p>The graph engine manages the underlying graph structure, including nodes and edges. It provides functionalities to modify the graph, retrieve graph elements, and maintain graph integrity.</p> <p>Returns:</p> Name Type Description <code>IGraphEngine</code> <code>IGraphEngine</code> <p>An instance of the graph engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the graph engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.ictx","title":"<code>ictx</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the internal context of the system.</p> <p>The internal context encapsulates core configurations, state information, and shared resources necessary for the operation of various system components.</p> <p>Returns:</p> Name Type Description <code>IInternalContext</code> <code>IInternalContext</code> <p>An instance representing the internal context.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the internal context is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.sensor","title":"<code>sensor</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the sensor engine.</p> <p>The sensor engine manages all sensor-related operations, including the creation, updating, and retrieval of sensors. It facilitates data collection from various sources within the system.</p> <p>Returns:</p> Name Type Description <code>ISensorEngine</code> <code>ISensorEngine</code> <p>An instance of the sensor engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the sensor engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.visual","title":"<code>visual</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the visualization engine.</p> <p>The visualization engine handles the rendering and display of the system's graphical elements, such as graphs and agents. It manages visual configurations and updates the visualization based on simulation states.</p> <p>Returns:</p> Name Type Description <code>IVisualizationEngine</code> <code>IVisualizationEngine</code> <p>An instance of the visualization engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the visualization engine is not properly initialized.</p>"},{"location":"first_game/","title":"Programming Your First GAMMS Game","text":""},{"location":"first_game/#introduction","title":"Introduction","text":"<p>This case study walks through setting up a GAMMS game from scratch. By following this guide, you will:</p> <p>\u2705 Configure a graph-based environment using <code>config.py</code>. \u2705 Implement agent strategies in <code>blue_strategy.py</code> (human-controlled) and <code>red_strategy.py</code> (AI-controlled). \u2705 Run the game simulation using <code>game.py</code>.  </p> <p>By the end, you'll have a working adversarial simulation where agents interact in a structured environment.</p>"},{"location":"first_game/#step-1-configuring-the-game-configpy","title":"Step 1: Configuring the Game (<code>config.py</code>)","text":"<p>The <code>config.py</code> file sets up the game environment, including: - Graph settings - Agent configurations - Sensor definitions - Visualization settings </p>"},{"location":"first_game/#configuration-code","title":"Configuration Code","text":"<pre><code>import gamms\n\n# Visualization Engine\nvis_engine = gamms.visual.Engine.PYGAME\n\n# Graph Configuration\nlocation = \"Sample Area\"\nresolution = 100.0\ngraph_path = 'graph.pkl'\n\n# Sensor Configuration\nsensor_config = {\n    'neigh_0': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_1': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_2': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_3': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_4': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_5': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_6': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_7': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_8': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_9': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'map': {'type': gamms.sensor.SensorType.MAP},\n    'agent': {'type': gamms.sensor.SensorType.AGENT},\n}\n\n# Agent Configuration For Two Teams\nagent_config = {\n    'agent_0': {'meta': {'team': 0}, 'sensors': ['neigh_0', 'map', 'agent'], 'start_node_id': 0},\n    'agent_1': {'meta': {'team': 0}, 'sensors': ['neigh_1', 'map', 'agent'], 'start_node_id': 1},\n    'agent_2': {'meta': {'team': 0}, 'sensors': ['neigh_2', 'map', 'agent'], 'start_node_id': 2},\n    'agent_3': {'meta': {'team': 0}, 'sensors': ['neigh_3', 'map', 'agent'], 'start_node_id': 3},\n    'agent_4': {'meta': {'team': 0}, 'sensors': ['neigh_4', 'map', 'agent'], 'start_node_id': 4},\n    'agent_5': {'meta': {'team': 1}, 'sensors': ['neigh_5', 'map', 'agent'], 'start_node_id': 500},\n    'agent_6': {'meta': {'team': 1}, 'sensors': ['neigh_6', 'map', 'agent'], 'start_node_id': 501},\n    'agent_7': {'meta': {'team': 1}, 'sensors': ['neigh_7', 'map', 'agent'], 'start_node_id': 502},\n    'agent_8': {'meta': {'team': 1}, 'sensors': ['neigh_8', 'map', 'agent'], 'start_node_id': 503},\n    'agent_9': {'meta': {'team': 1}, 'sensors': ['neigh_9', 'map', 'agent'], 'start_node_id': 504},\n}\n\n# Visualization Configuration\ngraph_vis_config = {'width': 1980, 'height': 1080}\n\nagent_vis_config = {\n    **{f'agent_{i}': {'color': 'blue', 'size': 8} for i in range(0, 5)},  # Blue Team\n    **{f'agent_{i}': {'color': 'red', 'size': 8} for i in range(500, 505)},  # Red Team\n}\n</code></pre>"},{"location":"first_game/#step-2-implementing-agent-behavior","title":"Step 2: Implementing Agent Behavior","text":"<p>Each team follows a different strategy: - Blue agents are human-controlled (no AI strategy). - Red agents use AI for movement decisions.  </p>"},{"location":"first_game/#blue-strategy-blue_strategypy","title":"Blue Strategy (<code>blue_strategy.py</code>)","text":"<p>Since Blue agents are human-controlled, we do not assign them an AI strategy.</p> <pre><code>def map_strategy(agent_config):\n    return {}  # No AI strategy for human-controlled players\n</code></pre>"},{"location":"first_game/#red-strategy-red_strategypy","title":"Red Strategy (<code>red_strategy.py</code>)","text":"<p>Red agents follow a random movement strategy, choosing a neighboring node at each turn.</p> <pre><code>import random\nfrom gamms import sensor\n\ndef strategy(state):\n    sensor_data = state['sensor']\n    for (sensor_type, neighbors) in sensor_data.values():\n        if sensor_type == sensor.SensorType.NEIGHBOR:\n            state['action'] = random.choice(neighbors)\n            break\n\ndef map_strategy(agent_config):\n    return {name: strategy for name in agent_config.keys()}\n</code></pre>"},{"location":"first_game/#step-3-running-the-simulation-gamepy","title":"Step 3: Running the Simulation (<code>game.py</code>)","text":"<p>The <code>game.py</code> script: \u2705 Initializes the game environment. \u2705 Loads the graph-based map. \u2705 Creates and assigns sensors to agents. \u2705 Registers strategies to agents. \u2705 Runs the simulation loop until termination.</p>"},{"location":"first_game/#game-execution-code","title":"Game Execution Code","text":"<pre><code>import gamms\nimport pickle\nfrom config import (\n    vis_engine,\n    graph_path,\n    sensor_config,\n    agent_config,\n    graph_vis_config,\n    agent_vis_config,\n)\nimport blue_strategy\nimport red_strategy\n\n# Create the game context\nctx = gamms.create_context(vis_engine=vis_engine)\n\n# Load the graph\nwith open(graph_path, 'rb') as f:\n    G = pickle.load(f)\n\nctx.graph.attach_networkx_graph(G)\n\n# Create the sensors\nfor name, sensor in sensor_config.items():\n    ctx.sensor.create_sensor(name, sensor['type'], **sensor.get('args', {}))\n\n# Create the agents\nfor name, agent in agent_config.items():\n    ctx.agent.create_agent(name, **agent)\n\n# Assign strategies: Blue is human-controlled, Red has AI\nstrategies = red_strategy.map_strategy(agent_config)\n\n# Register strategies for agents\nfor agent in ctx.agent.create_iter():\n    agent.register_strategy(strategies.get(agent.name, None))  # Blue agents get None (manual control)\n\n# Set visualization configurations\nctx.visual.set_graph_visual(**graph_vis_config)\n\nfor name, config in agent_vis_config.items():\n    ctx.visual.set_agent_visual(name, **config)\n\n#Termination Condition\nturn_count = 0\n\ndef rule_terminate(ctx):\n    global turn_count\n    turn_count += 1\n    if turn_count &gt; 100:\n        ctx.terminate()\n\n# Run the simulation\nwhile not ctx.is_terminated():\n    for agent in ctx.agent.create_iter():\n        if agent.strategy is not None:\n            agent.step()  # AI-controlled agent moves\n        else:\n            state = agent.get_state()\n            node = ctx.visual.human_input(agent.name, state)  # Human-controlled input\n            state['action'] = node\n            agent.set_state()\n\n    # Update visualization\n    ctx.visual.simulate()\n    rule_terminate(ctx)\n</code></pre>"},{"location":"first_game/#conclusion","title":"Conclusion","text":"<p>By following this structured approach, we successfully implemented a basic adversarial game in GAMMS. We: \u2705 Defined a graph-based environment for agents to explore. \u2705 Implemented human-controlled (Blue) and AI-controlled (Red) agents. \u2705 Ran a game simulation with interactive visualization.  </p> <p>Want to extend this? Try: \u2705 Creating an AI-controlled Blue Team for training scenarios. \u2705 Adding new sensor types for richer decision-making. \u2705 Implementing custom agent behaviors beyond random movement.  </p> <p>Start modifying your game today! \ud83d\ude80</p>"},{"location":"graph/","title":"Graph Engine","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing the graph engine.</p> <p>The graph engine manages the underlying graph structure, providing access and control over graph operations.</p>"},{"location":"graph/#gamms.typing.IGraphEngine.graph","title":"<code>graph</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current graph managed by the engine.</p> <p>Returns:</p> Name Type Description <code>IGraph</code> <code>IGraph</code> <p>The graph instance being managed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the graph has not been initialized.</p>"},{"location":"graph/#gamms.typing.IGraphEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the graph engine and perform necessary cleanup operations.</p> <p>This method should ensure that all resources allocated to the graph engine are properly released and that any ongoing operations are gracefully stopped.</p>"},{"location":"graph/#graph","title":"Graph","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a graph structure.</p> <p>The graph consists of nodes and edges, allowing for addition, removal, and retrieval of these elements.</p> <p>Represents a node within a graph.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for the node.</p> <code>x</code> <code>float</code> <p>The x-coordinate of the node's position.</p> <code>y</code> <code>float</code> <p>The y-coordinate of the node's position.</p> <p>Represents an OpenStreetMap (OSM) edge within a graph.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for the edge.</p> <code>source</code> <code>int</code> <p>The ID of the source node.</p> <code>target</code> <code>int</code> <p>The ID of the target node.</p> <code>length</code> <code>float</code> <p>The length of the edge.</p> <code>linestring</code> <code>List[Tuple[float, float]]</code> <p>A list of (x, y) tuples representing the geometry of the edge. Defaults to None.</p>"},{"location":"graph/#gamms.typing.IGraph.add_edge","title":"<code>add_edge(edge_data)</code>  <code>abstractmethod</code>","text":"<p>Add a new edge to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the edge's attributes. Expected keys include: - 'id' (int): Unique identifier for the edge. - 'source' (int): ID of the source node. - 'target' (int): ID of the target node. - 'length' (float): Length of the edge. - 'linestring' (List[Tuple[float, float]], optional): Geometry of the edge.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the edge_data is missing required fields, contains invalid data, or references non-existent nodes.</p> <code>KeyError</code> <p>If an edge with the same ID already exists in the graph.</p>"},{"location":"graph/#gamms.typing.IGraph.add_node","title":"<code>add_node(node_data)</code>  <code>abstractmethod</code>","text":"<p>Add a new node to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the node's attributes. Expected keys include: - 'id' (int): Unique identifier for the node. - 'x' (float): X-coordinate of the node. - 'y' (float): Y-coordinate of the node.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node_data is missing required fields or contains invalid data.</p> <code>KeyError</code> <p>If a node with the same ID already exists in the graph.</p>"},{"location":"graph/#gamms.typing.IGraph.get_edge","title":"<code>get_edge(edge_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the attributes of a specific edge.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>int</code> <p>The unique identifier of the edge to retrieve.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing the edge's attributes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge with the specified ID does not exist.</p>"},{"location":"graph/#gamms.typing.IGraph.get_edges","title":"<code>get_edges()</code>  <code>abstractmethod</code>","text":"<p>Retrieve a list of all edge IDs in the graph.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list containing the IDs of all edges.</p>"},{"location":"graph/#gamms.typing.IGraph.get_node","title":"<code>get_node(node_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the attributes of a specific node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to retrieve.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing the node's attributes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the node with the specified ID does not exist.</p>"},{"location":"graph/#gamms.typing.IGraph.get_nodes","title":"<code>get_nodes()</code>  <code>abstractmethod</code>","text":"<p>Retrieve a list of all node IDs in the graph.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list containing the IDs of all nodes.</p>"},{"location":"graph/#gamms.typing.IGraph.remove_edge","title":"<code>remove_edge(edge_id)</code>  <code>abstractmethod</code>","text":"<p>Remove an edge from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>int</code> <p>The unique identifier of the edge to be removed.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge with the specified ID does not exist.</p>"},{"location":"graph/#gamms.typing.IGraph.remove_node","title":"<code>remove_node(node_id)</code>  <code>abstractmethod</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to be removed.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the node with the specified ID does not exist.</p> <code>ValueError</code> <p>If removing the node would leave edges without valid source or target nodes.</p>"},{"location":"graph/#gamms.typing.IGraph.update_edge","title":"<code>update_edge(edge_data)</code>  <code>abstractmethod</code>","text":"<p>Update an existing edge's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>edge_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the edge's updated attributes. Must include: - 'id' (int): Unique identifier for the edge. - Any other attributes to be updated (e.g., 'source', 'target', 'length', 'linestring').</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge with the specified ID does not exist.</p> <code>ValueError</code> <p>If the provided data is invalid or references non-existent nodes.</p>"},{"location":"graph/#gamms.typing.IGraph.update_node","title":"<code>update_node(node_data)</code>  <code>abstractmethod</code>","text":"<p>Update an existing node's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>node_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the node's updated attributes. Must include: - 'id' (int): Unique identifier for the node. - Any other attributes to be updated (e.g., 'x', 'y').</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the node with the specified ID does not exist.</p> <code>ValueError</code> <p>If the provided data is invalid.</p>"},{"location":"sensor/","title":"Sensor Engine","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a sensor engine.</p> <p>The sensor engine manages the lifecycle of sensors, including their creation, retrieval, and termination. It serves as a central point for interacting with various sensors within the system.</p>"},{"location":"sensor/#gamms.typing.ISensorEngine.create_sensor","title":"<code>create_sensor(sensor_type, sensor_data)</code>  <code>abstractmethod</code>","text":"<p>Create a new sensor of the specified type.</p> <p>This method initializes a sensor based on the provided type and data, and registers it within the sensor engine for management.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_type</code> <code>SensorType</code> <p>The type of sensor to create.</p> required <code>sensor_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing initial data for the sensor.</p> required <p>Returns:</p> Name Type Description <code>ISensor</code> <code>ISensor</code> <p>The newly created sensor instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sensor_type is unsupported or sensor_data is invalid.</p> <code>RuntimeError</code> <p>If the sensor cannot be created due to system constraints.</p>"},{"location":"sensor/#gamms.typing.ISensorEngine.get_sensor","title":"<code>get_sensor(sensor_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve a sensor by its unique identifier.</p> <p>This method fetches the sensor instance corresponding to the provided sensor_id.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_id</code> <code>Any</code> <p>The unique identifier of the sensor to retrieve.</p> required <p>Returns:</p> Name Type Description <code>ISensor</code> <code>ISensor</code> <p>The sensor instance associated with the provided sensor_id.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no sensor with the specified sensor_id exists.</p> <code>TypeError</code> <p>If the sensor_id is of an incorrect type.</p>"},{"location":"sensor/#gamms.typing.ISensorEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the sensor engine and perform necessary cleanup operations.</p> <p>This method gracefully shuts down the sensor engine, ensuring that all sensors are properly terminated and that resources are released.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the sensor engine fails to terminate gracefully.</p> <code>IOError</code> <p>If there are issues during the cleanup process.</p>"},{"location":"sensor/#sensor","title":"Sensor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a generic sensor.</p> <p>Sensors are responsible for collecting data related to specific aspects of the system. Each sensor has a type and maintains its own data state.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>SensorType</code> <p>The type of the sensor.</p> <code>data</code> <code>Dict[str, Any]</code> <p>The data collected or maintained by the sensor.</p>"},{"location":"sensor/#gamms.typing.ISensor.sense","title":"<code>sense(node_id)</code>  <code>abstractmethod</code>","text":"<p>Perform sensing operations for a given node.</p> <p>This method collects data related to the specified node and returns the sensed information.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to sense.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing the sensed data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided node_id is invalid.</p> <code>RuntimeError</code> <p>If the sensing operation fails due to system constraints.</p>"},{"location":"sensor/#gamms.typing.ISensor.update","title":"<code>update(data)</code>  <code>abstractmethod</code>","text":"<p>Update the sensor's data.</p> <p>This method modifies the sensor's internal data based on the provided information.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the data to update the sensor with.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the provided data contains invalid keys.</p> <code>ValueError</code> <p>If the provided data is malformed or incomplete.</p>"},{"location":"sensor/#sensor-type","title":"Sensor Type","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of different sensor types.</p> <p>Attributes:</p> Name Type Description <code>NEIGHBOR</code> <code>Enum</code> <p>Sensor type for detecting neighboring entities. Data Representation (<code>List[int]</code>): List of node identifiers representing neighbors.</p> <code>MAP</code> <code>Enum</code> <p>Sensor type for map-related data. Data Representation (<code>Tuple[Dict[int, Node], Dict[int, OSMEdge]</code>): Tuple containing node and edge data.</p> <code>AGENT</code> <code>Enum</code> <p>Sensor type for agent locations. Data Representation (<code>Dict[str, int]</code>): Dictionary mapping agent names to node identifiers.</p>"},{"location":"start/","title":"Getting Started","text":"<p>Gamms is a library designed to simulate adversial games in a graph based world. This guide will help you quickly install and set up Gamms so you can start experimenting as soon as possible.</p>"},{"location":"start/#python-requierement","title":"Python Requierement","text":"<p>Gamms requires Python 3.9 or later. If you already have a suitable version installed, skip to Installation and Setup.</p> <p>Otherwise, visit the official Python download page to install a compatible version for your device (Windows, Mac, or Linux): Python</p>"},{"location":"start/#installation-and-setup","title":"Installation and Setup","text":"<p>Before installing Gamms, ensure that pip is installed. Most Python distributions include pip by default; if you need to install it separately, follow the instructions on the pip documentation page.</p> <p>Once pip is set up, use the appropriate commands below for your operating system.</p>"},{"location":"start/#installing-git","title":"Installing Git","text":"Mac <ul> <li>Git via Homebrew</li> <li>Wget via Homebrew</li> </ul> Linux <ul> <li><code>sudo apt-get install git wget</code> (Debian/Ubuntu)</li> <li><code>sudo dnf install git wget</code> (Fedora)</li> <li><code>sudo pacman -S git wget</code> (Arch)</li> </ul> Windows <ul> <li>Git for Windows</li> <li>Wget for Windows</li> </ul>"},{"location":"start/#creating-a-project-folder-and-virtual-environment","title":"Creating a Project Folder and Virtual Environment","text":"<p>Create a new folder in the directory where you want your project to live. We'll name it <code>gamms</code>: <pre><code>mkdir gamms\ncd gamms\n</code></pre> Create a Python virtual environment within this folder. You can do this using <code>python</code> or <code>python3</code>, depending on your system: <pre><code>python -m venv venv\n</code></pre></p> <p>This command will create a subfolder named <code>venv</code> that contains your virtual environment files.</p> <p>Activate the virtual environment:</p> Mac/Linux <pre><code>source venv/bin/activate\n</code></pre> Windows <pre><code>venv\\Scripts\\activate\n</code></pre> <p>Install Gamms within the virtual environment: <pre><code>python -m pip install git+https://github.com/GAMMSim/gamms.git\n</code></pre></p> <p>Verify your installation: <pre><code>   import gamms\n   print(\"Gamms version:\", gamms.__version__)\n</code></pre></p> <p>Once these steps are completed, you will have Gamms installed in a clean virtual environment. Remember to activate the virtual environment (step 3) whenever you want to work on your project.</p>"},{"location":"start/#running-examples","title":"Running Examples","text":"<p>Clone or download the <code>examples</code> directory from GAMMSim/gamms.</p> Git <pre><code>git clone https://github.com/GAMMSim/gamms.git\nmv gamms/examples examples\nrm -rf gamms\n</code></pre> Wget <pre><code>wget https://github.com/GAMMSim/gamms/archive/refs/heads/main.zip\nunzip main.zip\nmv gamms-main/examples examples\nrm -rf gamms-main main.zip\n</code></pre> <p>Execute the script: <pre><code>python create_graph.py\n</code></pre> Verify that a <code>.pkl</code> file is successfully created. This indicates that the graph has been created properly.</p> <p>Creating Strategy and Configuration Files</p> <p>Step 1: Create a folder named <code>games</code> (in the root of your project directory):    <pre><code>mkdir games\n</code></pre> Step 2: Inside the <code>games</code> folder, create three Python files:</p> <ul> <li><code>blue_strategy.py</code> </li> <li><code>red_strategy.py</code> </li> <li><code>config.py</code></li> </ul> <p>Step 3: Implement the logic for each file according to your specific needs. For example:</p> <ul> <li><code>blue_strategy.py</code> might define functions or classes related to the Blue team's strategy.</li> <li><code>red_strategy.py</code> might define functions or classes related to the Red team's strategy.</li> <li><code>config.py</code> might define shared constants, environment variables, or other settings.</li> </ul>"},{"location":"visual/","title":"Visualization","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a visualization engine.</p> <p>The visualization engine is responsible for rendering the graph and agents, handling simulation updates, processing human inputs, and managing the overall visualization lifecycle.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.add_artist","title":"<code>add_artist(name, data)</code>  <code>abstractmethod</code>","text":"<p>Add a custom artist or object to the visualization.</p> <p>This method adds a custom artist or object to the visualization, allowing for additional elements to be displayed alongside the graph and agents. The artist can be used to render custom shapes, text, images, or other visual components within the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier for the custom artist.</p> required <code>data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the data and settings for the custom artist. The structure of the data may vary based on the type of artist being added.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.human_input","title":"<code>human_input(agent_name, state)</code>  <code>abstractmethod</code>","text":"<p>Process input from a human player or user.</p> <p>This method handles input data provided by a human user, allowing for interactive control or modification of the visualization. It can be used to receive commands, adjust settings, or influence the simulation based on user actions.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Dict[str, Any]</code> <p>A dictionary containing the current state of the system or the input data from the user. Expected keys may include: - <code>command</code> (str): The command issued by the user. - <code>parameters</code> (Dict[str, Any]): Additional parameters related to the command. - Other state-related information as needed.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The target node id selected by the user.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input <code>state</code> contains invalid or unsupported commands.</p> <code>KeyError</code> <p>If required keys are missing from the <code>state</code> dictionary.</p> <code>TypeError</code> <p>If the types of the provided input data do not match expected types.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.remove_artist","title":"<code>remove_artist(name)</code>  <code>abstractmethod</code>","text":"<p>Remove a custom artist or object from the visualization.</p> <p>This method removes a custom artist or object from the visualization, effectively hiding or deleting the element from the display.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the custom artist to remove.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.set_agent_visual","title":"<code>set_agent_visual(agent_name, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Configure the visual representation of a specific agent.</p> <p>This method sets up visual parameters for an individual agent, allowing customization of how the agent is displayed within the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>The unique name identifier of the agent to configure.</p> required <code>**kwargs</code> <p>Arbitrary keyword arguments representing visual settings. Possible keys include: - <code>color</code> (str): The color to represent the agent. - <code>shape</code> (str): The shape to use for the agent's representation. - <code>size</code> (float): The size of the agent in the visualization. - <code>icon</code> (str): Path to an icon image to represent the agent. - Additional visual parameters as needed.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no agent with the specified <code>agent_name</code> exists.</p> <code>ValueError</code> <p>If any of the provided visual settings are invalid.</p> <code>TypeError</code> <p>If the types of the provided settings do not match expected types.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.set_graph_visual","title":"<code>set_graph_visual(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Configure the visual representation of the graph.</p> <p>This method sets up visual parameters such as colors, sizes, layouts, and other graphical attributes for the entire graph. It allows customization of how the graph is displayed to the user.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments representing visual settings. Possible keys include: - <code>color_scheme</code> (str): The color scheme to use for nodes and edges. - <code>layout</code> (str): The layout algorithm for positioning nodes. - <code>node_size</code> (float): The size of the graph nodes. - <code>edge_width</code> (float): The width of the graph edges. - Additional visual parameters as needed.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the provided visual settings are invalid.</p> <code>TypeError</code> <p>If the types of the provided settings do not match expected types.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.simulate","title":"<code>simulate()</code>  <code>abstractmethod</code>","text":"<p>Execute a simulation step to update the visualization.</p> <p>This method advances the simulation by one step, updating the positions, states, and visual representations of the graph and agents. It should be called repeatedly within a loop to animate the visualization in real-time.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the simulation cannot be advanced due to internal errors.</p> <code>ValueError</code> <p>If the simulation parameters are invalid or inconsistent.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the visualization engine and clean up resources.</p> <p>This method is called when the simulation or application is exiting. It should handle the graceful shutdown of the visualization engine, ensuring that all resources are properly released and that the display is correctly closed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the engine fails to terminate gracefully.</p> <code>IOError</code> <p>If there are issues during the cleanup process.</p>"}]}