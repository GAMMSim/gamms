{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GAMMS: Graph based Adversarial Multiagent Modelling Simulator","text":"<p>GAMMS (Graph based Adversarial Multiagent Modelling Simulator) is a Python library designed for simulating large scale multi-agent scenarios on environments represented as graphs. The library is a framework which focuses on providing a flexible and extensible architecture to facilitate implementing interactions between agents and the environment as well as controlling the information flow between them. The library is geared towards easing development of high level scenario dynamics and testing agent behaviours rather than low level details like the actual physics of real world interactions. GAMMS tries to solve the following problems:</p> <ol> <li>Run large simulations involving multiple agents on an everyday laptop.</li> <li>Provide a simple interface to the user to define the agents and the environment.</li> <li>Allow the user to work with the agents and the environment without worrying about the underlying packages.</li> <li>Create a simulater that is easy to use on any operating system (Windows, Mac, Linux) and is easy to install.</li> </ol> <p>The uniqueness of GAMMS comes from what it is not trying to be. It is not a physics engine, game engine, deep learning library, or a reinforcement learning library. The goal of GAMMS is to provide a framework where the user can use any of these libraries to implement their own agents and environments. Other libraries like Unity, PyBullet, and OpenAI Gym are great for simulating environments but they are not designed to be used as a framework for multi-agent simulations on graphs. GAMMS is trying to address the niche use for researchers and developers who want to do a quick iterations on their ideas and test them in simulated environments that have limited interactions. GAMMS want to be a tool to create a standardized way for simulating multi-agent systems, making it easier to share and reproduce results.</p> <pre><code>---\ntitle: GAMMS - Graph based Adversarial Multiagent Modelling Simulator\n---\nstateDiagram-v2\n    direction LR\n    classDef red fill:#f9e79f,stroke:#d4ac0d\n    classDef blue fill:#aed6f1,stroke:#3498db\n    state \"Provided by GAMMS\" as S {\n        direction LR\n        RealWorld --&gt; Graph : Convert\n        Scenario --&gt; Sensors : Define\n        Scenario --&gt; Agents : Define\n        Graph --&gt; Game\n        Sensors --&gt; Game\n        Agents --&gt; Game\n        Game --&gt; RedAgentStates\n        Game --&gt; BlueAgentStates\n    }\n    state \"Red Team\" as R{\n        direction LR\n        RedAgentStates --&gt; RedStrategy : Input\n        RedStrategy --&gt; RedAgentStates : Update\n    }\n    state \"Blue Team\" as B{\n        direction LR\n        BlueAgentStates --&gt; BlueStrategy : Input\n        BlueStrategy --&gt; BlueAgentStates : Update\n    }\n    RedAgentStates --&gt; Game\n    BlueAgentStates --&gt; Game\n    Class R, red\n    Class B, blue\n    Class RedAgentStates, red\n    Class BlueAgentStates, blue\n    Class RedStrategy, red\n    Class BlueStrategy, blue</code></pre> <p>The diagram above illustrates on a high level how GAMMS works. The user defines the environment and the agents, and GAMMS takes care of the rest. The user can focus on implementing the strategies for the agents and the interactions between them, while GAMMS handles the simulation and the information flow.</p>"},{"location":"agent/","title":"Agent Engine","text":""},{"location":"agent/#gamms.typing.agent_engine.AgentType","title":"<code>AgentType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum representing different types of agents.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>class AgentType(IntEnum):\n    \"\"\"\n    Enum representing different types of agents.\n    \"\"\"\n    BASIC = 0\n    AERIAL = 1\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAerialAgent","title":"<code>IAerialAgent</code>","text":"<p>               Bases: <code>IAgent</code></p> <p>Abstract base class representing an aerial agent in the system.</p> <p>This class extends the basic agent functionality to include aerial-specific behaviors.</p> <p>Requires a start node ID and speed for initialization.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>class IAerialAgent(IAgent):\n    \"\"\"\n    Abstract base class representing an aerial agent in the system.\n\n    This class extends the basic agent functionality to include aerial-specific behaviors.\n\n    Requires a start node ID and speed for initialization.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def quat(self) -&gt; Tuple[float, float, float, float]:\n        \"\"\"\n        Get the quaternion representation of the agent's orientation.\n        Formatted as (w, x, y, z).\n\n        Returns:\n            Tuple[float, float, float, float]: The quaternion representing the agent's orientation.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def orientation(self) -&gt; Tuple[float, float]:\n        \"\"\"\n        Get the orientation of the agent in the x-y plane.\n\n        Returns:\n            Tuple[float, float]: The current orientation of the agent as a tuple (sin, cos).\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def position(self) -&gt; Tuple[float, float, float]:\n        \"\"\"\n        Get the current position of the agent in 3D space.\n\n        Returns:\n            Tuple[float, float, float]: The current position of the agent as a tuple (x, y, z).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_state(self):\n        \"\"\"\n        Update the agent's position and orientation.\n        Action should be a 3d direction tuple. It will be normalized to a unit vector and multiplied by the agent's speed.\n\n        Action can also be a dictionary with 'direction' key to specify the direction and have 'quat' key to specify the quaternion orientation.\n\n        Raises:\n            KeyError: If action is not found in the agent's state.\n            TypeError: If action is not a tuple or dict.\n            ValueError: If action dict does not contain 'direction' key\n            ValueError: If quat is not a tuple of (w, x, y, z).\n        \"\"\"\n        pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAerialAgent.orientation","title":"<code>orientation</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the orientation of the agent in the x-y plane.</p> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: The current orientation of the agent as a tuple (sin, cos).</p>"},{"location":"agent/#gamms.typing.agent_engine.IAerialAgent.position","title":"<code>position</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current position of the agent in 3D space.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Tuple[float, float, float]: The current position of the agent as a tuple (x, y, z).</p>"},{"location":"agent/#gamms.typing.agent_engine.IAerialAgent.quat","title":"<code>quat</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the quaternion representation of the agent's orientation. Formatted as (w, x, y, z).</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>Tuple[float, float, float, float]: The quaternion representing the agent's orientation.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAerialAgent.set_state","title":"<code>set_state()</code>  <code>abstractmethod</code>","text":"<p>Update the agent's position and orientation. Action should be a 3d direction tuple. It will be normalized to a unit vector and multiplied by the agent's speed.</p> <p>Action can also be a dictionary with 'direction' key to specify the direction and have 'quat' key to specify the quaternion orientation.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If action is not found in the agent's state.</p> <code>TypeError</code> <p>If action is not a tuple or dict.</p> <code>ValueError</code> <p>If action dict does not contain 'direction' key</p> <code>ValueError</code> <p>If quat is not a tuple of (w, x, y, z).</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef set_state(self):\n    \"\"\"\n    Update the agent's position and orientation.\n    Action should be a 3d direction tuple. It will be normalized to a unit vector and multiplied by the agent's speed.\n\n    Action can also be a dictionary with 'direction' key to specify the direction and have 'quat' key to specify the quaternion orientation.\n\n    Raises:\n        KeyError: If action is not found in the agent's state.\n        TypeError: If action is not a tuple or dict.\n        ValueError: If action dict does not contain 'direction' key\n        ValueError: If quat is not a tuple of (w, x, y, z).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent","title":"<code>IAgent</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing an agent in the system.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>class IAgent(ABC):\n    \"\"\"\n    Abstract base class representing an agent in the system.\n\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name identifier of the agent.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def current_node_id(self) -&gt; int:\n        \"\"\"\n        Get the current node ID of the agent.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def prev_node_id(self) -&gt; int:\n        \"\"\"\n        Get the previous node ID of the agent.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def type(self) -&gt; AgentType:\n        \"\"\"\n        Get the type of the agent.\n\n        Returns:\n            AgentType: The type of the agent (e.g., BASIC, AERIAL).\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def orientation(self) -&gt; Tuple[float, float]:\n        \"\"\"\n        Get the orientation of the agent.\n\n        Returns:\n            Tuple[float, float]: The current orientation of the agent.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def state(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the current state of the agent.\n\n        Returns:\n            Dict[str, Any]: The current state data of the agent.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def strategy(self) -&gt; Optional[Callable[[Dict[str, Any]], None]]:\n        \"\"\"\n        Get the current strategy of the agent.\n\n        Returns:\n            Optional[Callable[[Dict[str, Any]], None]]: The current strategy function or None if no strategy is set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def step(self):\n        \"\"\"\n        Execute a single operational step of the agent.\n\n        This method should contain the logic that defines the agent's behavior\n        during one iteration or time step in the system.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_state(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieve the current state of the agent.\n\n        Returns:\n            Dict[str, Any]: The current state data of the agent, structure depends on implementation.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_state(self):\n        \"\"\"\n        Update the agent's state.\n\n        Raises:\n            KeyError: If action is not found in the agent's state.\n            KeyError: If action is an int but not a valid node ID.\n            TypeError: If action is not an int or dict.\n            ValueError: If action dict does not contain 'node_id' key\n            ValueError: If orientation is not a tuple of (sin, cos).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def register_sensor(self, name: str, sensor: ISensor):\n        \"\"\"\n        Register a sensor with the agent.\n\n        Sensors can be used by the agent to perceive the environment or gather data.\n\n        Args:\n            name (str): The unique name identifier for the sensor.\n            sensor (ISensor): The sensor instance or object to be registered.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def deregister_sensor(self, name: str):\n        \"\"\"\n        Deregister a sensor from the agent.\n\n        Args:\n            name (str): The unique name identifier for the sensor to be deregistered.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def register_strategy(self, strategy: Callable[[Dict[str, Any]], None]):\n        \"\"\"\n        Register a strategy with the agent.\n\n        Strategies define the decision-making or action-planning mechanisms for the agent.\n\n        Args:\n            strategy (Callable[[Dict[str, Any]], None]): The strategy instance or object to be registered.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.current_node_id","title":"<code>current_node_id</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current node ID of the agent.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the name identifier of the agent.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.orientation","title":"<code>orientation</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the orientation of the agent.</p> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: The current orientation of the agent.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.prev_node_id","title":"<code>prev_node_id</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the previous node ID of the agent.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.state","title":"<code>state</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current state of the agent.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The current state data of the agent.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.strategy","title":"<code>strategy</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current strategy of the agent.</p> <p>Returns:</p> Type Description <code>Optional[Callable[[Dict[str, Any]], None]]</code> <p>Optional[Callable[[Dict[str, Any]], None]]: The current strategy function or None if no strategy is set.</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.type","title":"<code>type</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the type of the agent.</p> <p>Returns:</p> Name Type Description <code>AgentType</code> <code>AgentType</code> <p>The type of the agent (e.g., BASIC, AERIAL).</p>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.deregister_sensor","title":"<code>deregister_sensor(name)</code>  <code>abstractmethod</code>","text":"<p>Deregister a sensor from the agent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier for the sensor to be deregistered.</p> required Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef deregister_sensor(self, name: str):\n    \"\"\"\n    Deregister a sensor from the agent.\n\n    Args:\n        name (str): The unique name identifier for the sensor to be deregistered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.get_state","title":"<code>get_state()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the current state of the agent.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The current state data of the agent, structure depends on implementation.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef get_state(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieve the current state of the agent.\n\n    Returns:\n        Dict[str, Any]: The current state data of the agent, structure depends on implementation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.register_sensor","title":"<code>register_sensor(name, sensor)</code>  <code>abstractmethod</code>","text":"<p>Register a sensor with the agent.</p> <p>Sensors can be used by the agent to perceive the environment or gather data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier for the sensor.</p> required <code>sensor</code> <code>ISensor</code> <p>The sensor instance or object to be registered.</p> required Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef register_sensor(self, name: str, sensor: ISensor):\n    \"\"\"\n    Register a sensor with the agent.\n\n    Sensors can be used by the agent to perceive the environment or gather data.\n\n    Args:\n        name (str): The unique name identifier for the sensor.\n        sensor (ISensor): The sensor instance or object to be registered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.register_strategy","title":"<code>register_strategy(strategy)</code>  <code>abstractmethod</code>","text":"<p>Register a strategy with the agent.</p> <p>Strategies define the decision-making or action-planning mechanisms for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Callable[[Dict[str, Any]], None]</code> <p>The strategy instance or object to be registered.</p> required Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef register_strategy(self, strategy: Callable[[Dict[str, Any]], None]):\n    \"\"\"\n    Register a strategy with the agent.\n\n    Strategies define the decision-making or action-planning mechanisms for the agent.\n\n    Args:\n        strategy (Callable[[Dict[str, Any]], None]): The strategy instance or object to be registered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.set_state","title":"<code>set_state()</code>  <code>abstractmethod</code>","text":"<p>Update the agent's state.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If action is not found in the agent's state.</p> <code>KeyError</code> <p>If action is an int but not a valid node ID.</p> <code>TypeError</code> <p>If action is not an int or dict.</p> <code>ValueError</code> <p>If action dict does not contain 'node_id' key</p> <code>ValueError</code> <p>If orientation is not a tuple of (sin, cos).</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef set_state(self):\n    \"\"\"\n    Update the agent's state.\n\n    Raises:\n        KeyError: If action is not found in the agent's state.\n        KeyError: If action is an int but not a valid node ID.\n        TypeError: If action is not an int or dict.\n        ValueError: If action dict does not contain 'node_id' key\n        ValueError: If orientation is not a tuple of (sin, cos).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgent.step","title":"<code>step()</code>  <code>abstractmethod</code>","text":"<p>Execute a single operational step of the agent.</p> <p>This method should contain the logic that defines the agent's behavior during one iteration or time step in the system.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef step(self):\n    \"\"\"\n    Execute a single operational step of the agent.\n\n    This method should contain the logic that defines the agent's behavior\n    during one iteration or time step in the system.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgentEngine","title":"<code>IAgentEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing the engine that manages agents.</p> <p>The engine is responsible for creating, managing, and terminating agents, as well as facilitating interactions between them.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>class IAgentEngine(ABC):\n    \"\"\"\n    Abstract base class representing the engine that manages agents.\n\n    The engine is responsible for creating, managing, and terminating agents,\n    as well as facilitating interactions between them.\n    \"\"\"\n\n    @abstractmethod\n    def create_iter(self) -&gt; Iterable[IAgent]:\n        \"\"\"\n        Create an iterator for processing agent steps.\n\n        Returns:\n            Iterable[IAgent]: An iterator object over all agents.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def create_agent(self, name:str, **kwargs: Dict[str, Any]) -&gt; IAgent:\n        \"\"\"\n        Instantiate a new agent within the engine.\n\n        Args:\n            name (str): The unique name identifier for the agent.\n            **kwargs: Additional keyword arguments for agent initialization.\n\n        Returns:\n            IAgent: The newly created agent instance.\n\n        Raises:\n            ValueError: If an agent with the same name already exists.\n            KeyError: If start_node_id is not provided in kwargs.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def terminate(self):\n        \"\"\"\n        Terminate the agent engine and perform necessary cleanup operations.\n\n        This method should ensure that all resources are properly released and\n        that agents are gracefully shut down.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_agent(self, name: str) -&gt; IAgent:\n        \"\"\"\n        Retrieve an agent by its name.\n\n        Args:\n            name (str): The unique name identifier of the agent to retrieve.\n\n        Returns:\n            IAgent: The agent instance corresponding to the provided name.\n\n        Raises:\n            KeyError: If no agent with the specified name exists.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_agent(self, name: str) -&gt; None:\n        \"\"\"\n        Delete an agent by its name.\n\n        Args:\n            name (str): The unique name identifier of the agent to retrieve.\n\n        Returns:\n            None\n\n        Raises:\n            Logs a warning and does nothing if no agent with the specified name exists.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgentEngine.create_agent","title":"<code>create_agent(name, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Instantiate a new agent within the engine.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier for the agent.</p> required <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments for agent initialization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>IAgent</code> <code>IAgent</code> <p>The newly created agent instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an agent with the same name already exists.</p> <code>KeyError</code> <p>If start_node_id is not provided in kwargs.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef create_agent(self, name:str, **kwargs: Dict[str, Any]) -&gt; IAgent:\n    \"\"\"\n    Instantiate a new agent within the engine.\n\n    Args:\n        name (str): The unique name identifier for the agent.\n        **kwargs: Additional keyword arguments for agent initialization.\n\n    Returns:\n        IAgent: The newly created agent instance.\n\n    Raises:\n        ValueError: If an agent with the same name already exists.\n        KeyError: If start_node_id is not provided in kwargs.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgentEngine.create_iter","title":"<code>create_iter()</code>  <code>abstractmethod</code>","text":"<p>Create an iterator for processing agent steps.</p> <p>Returns:</p> Type Description <code>Iterable[IAgent]</code> <p>Iterable[IAgent]: An iterator object over all agents.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef create_iter(self) -&gt; Iterable[IAgent]:\n    \"\"\"\n    Create an iterator for processing agent steps.\n\n    Returns:\n        Iterable[IAgent]: An iterator object over all agents.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgentEngine.delete_agent","title":"<code>delete_agent(name)</code>  <code>abstractmethod</code>","text":"<p>Delete an agent by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the agent to retrieve.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef delete_agent(self, name: str) -&gt; None:\n    \"\"\"\n    Delete an agent by its name.\n\n    Args:\n        name (str): The unique name identifier of the agent to retrieve.\n\n    Returns:\n        None\n\n    Raises:\n        Logs a warning and does nothing if no agent with the specified name exists.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgentEngine.get_agent","title":"<code>get_agent(name)</code>  <code>abstractmethod</code>","text":"<p>Retrieve an agent by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the agent to retrieve.</p> required <p>Returns:</p> Name Type Description <code>IAgent</code> <code>IAgent</code> <p>The agent instance corresponding to the provided name.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no agent with the specified name exists.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef get_agent(self, name: str) -&gt; IAgent:\n    \"\"\"\n    Retrieve an agent by its name.\n\n    Args:\n        name (str): The unique name identifier of the agent to retrieve.\n\n    Returns:\n        IAgent: The agent instance corresponding to the provided name.\n\n    Raises:\n        KeyError: If no agent with the specified name exists.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.IAgentEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the agent engine and perform necessary cleanup operations.</p> <p>This method should ensure that all resources are properly released and that agents are gracefully shut down.</p> Source code in <code>gamms/typing/agent_engine.py</code> <pre><code>@abstractmethod\ndef terminate(self):\n    \"\"\"\n    Terminate the agent engine and perform necessary cleanup operations.\n\n    This method should ensure that all resources are properly released and\n    that agents are gracefully shut down.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.ISensor","title":"<code>ISensor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a generic sensor.</p> <p>Sensors are responsible for collecting data related to specific aspects of the system. Each sensor has a type and maintains its own data state.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>SensorType</code> <p>The type of the sensor.</p> <code>data</code> <code>Dict[str, Any]</code> <p>The data collected or maintained by the sensor.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>class ISensor(ABC):\n    \"\"\"\n    Abstract base class representing a generic sensor.\n\n    Sensors are responsible for collecting data related to specific aspects of the system.\n    Each sensor has a type and maintains its own data state.\n\n    Attributes:\n        type (SensorType): The type of the sensor.\n        data (Dict[str, Any]): The data collected or maintained by the sensor.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def sensor_id(self) -&gt; str:\n        \"\"\"\n        Get the unique identifier of the sensor.\n\n        Returns:\n            str: The unique identifier of the sensor.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def type(self) -&gt; SensorType:\n        \"\"\"\n        Get the type of the sensor.\n\n        Returns:\n            SensorType: The type of the sensor.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def data(self) -&gt; Union[Dict[str, Any], List[int]]:\n        \"\"\"\n        Get the current data maintained by the sensor.\n\n        Returns:\n            Dict[str, Any]: The data maintained by the sensor.\n            List[int]: A list of node identifiers for the NEIGHBOR sensor type.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def sense(self, node_id: int) -&gt; None:\n        \"\"\"\n        Perform sensing operations for a given node.\n\n        This method collects data related to the specified node and returns the sensed information.\n\n        Args:\n            node_id (int): The unique identifier of the node to sense.\n\n        Sensed Data type:\n            Dict[str, Any]: A dictionary containing the sensed data.\n            Only Neigbor sensor returns a list of node ids. List[int]\n\n        Raises:\n            ValueError: If the provided node_id is invalid.\n            RuntimeError: If the sensing operation fails due to system constraints.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update the sensor's data.\n\n        This method modifies the sensor's internal data based on the provided information.\n\n        Args:\n            data (Dict[str, Any]): A dictionary containing the data to update the sensor with.\n\n        Raises:\n            KeyError: If the provided data contains invalid keys.\n            ValueError: If the provided data is malformed or incomplete.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_owner(self, owner: Union[str, None]) -&gt; None:\n        \"\"\"\n        Set the owner of the sensor. Owner is a string that identifies the entity responsible for the sensor.\n        Used for setting the owning agent.\n\n        This method assigns a specific owner to the sensor, which can be used for identification\n        or management purposes.\n\n        Args:\n            owner (str or None): The name of the owner to assign to the sensor.\n\n        Raises:\n            TypeError: If the provided owner is not a string.\n            ValueError: If the provided owner is invalid or empty.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.ISensor.data","title":"<code>data</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current data maintained by the sensor.</p> <p>Returns:</p> Type Description <code>Union[Dict[str, Any], List[int]]</code> <p>Dict[str, Any]: The data maintained by the sensor.</p> <code>Union[Dict[str, Any], List[int]]</code> <p>List[int]: A list of node identifiers for the NEIGHBOR sensor type.</p>"},{"location":"agent/#gamms.typing.agent_engine.ISensor.sensor_id","title":"<code>sensor_id</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the unique identifier of the sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier of the sensor.</p>"},{"location":"agent/#gamms.typing.agent_engine.ISensor.type","title":"<code>type</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the type of the sensor.</p> <p>Returns:</p> Name Type Description <code>SensorType</code> <code>SensorType</code> <p>The type of the sensor.</p>"},{"location":"agent/#gamms.typing.agent_engine.ISensor.sense","title":"<code>sense(node_id)</code>  <code>abstractmethod</code>","text":"<p>Perform sensing operations for a given node.</p> <p>This method collects data related to the specified node and returns the sensed information.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to sense.</p> required Sensed Data type <p>Dict[str, Any]: A dictionary containing the sensed data. Only Neigbor sensor returns a list of node ids. List[int]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided node_id is invalid.</p> <code>RuntimeError</code> <p>If the sensing operation fails due to system constraints.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef sense(self, node_id: int) -&gt; None:\n    \"\"\"\n    Perform sensing operations for a given node.\n\n    This method collects data related to the specified node and returns the sensed information.\n\n    Args:\n        node_id (int): The unique identifier of the node to sense.\n\n    Sensed Data type:\n        Dict[str, Any]: A dictionary containing the sensed data.\n        Only Neigbor sensor returns a list of node ids. List[int]\n\n    Raises:\n        ValueError: If the provided node_id is invalid.\n        RuntimeError: If the sensing operation fails due to system constraints.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.ISensor.set_owner","title":"<code>set_owner(owner)</code>  <code>abstractmethod</code>","text":"<p>Set the owner of the sensor. Owner is a string that identifies the entity responsible for the sensor. Used for setting the owning agent.</p> <p>This method assigns a specific owner to the sensor, which can be used for identification or management purposes.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str or None</code> <p>The name of the owner to assign to the sensor.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided owner is not a string.</p> <code>ValueError</code> <p>If the provided owner is invalid or empty.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef set_owner(self, owner: Union[str, None]) -&gt; None:\n    \"\"\"\n    Set the owner of the sensor. Owner is a string that identifies the entity responsible for the sensor.\n    Used for setting the owning agent.\n\n    This method assigns a specific owner to the sensor, which can be used for identification\n    or management purposes.\n\n    Args:\n        owner (str or None): The name of the owner to assign to the sensor.\n\n    Raises:\n        TypeError: If the provided owner is not a string.\n        ValueError: If the provided owner is invalid or empty.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent/#gamms.typing.agent_engine.ISensor.update","title":"<code>update(data)</code>  <code>abstractmethod</code>","text":"<p>Update the sensor's data.</p> <p>This method modifies the sensor's internal data based on the provided information.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the data to update the sensor with.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the provided data contains invalid keys.</p> <code>ValueError</code> <p>If the provided data is malformed or incomplete.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef update(self, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update the sensor's data.\n\n    This method modifies the sensor's internal data based on the provided information.\n\n    Args:\n        data (Dict[str, Any]): A dictionary containing the data to update the sensor with.\n\n    Raises:\n        KeyError: If the provided data contains invalid keys.\n        ValueError: If the provided data is malformed or incomplete.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"agent_state_addition/","title":"Passing Extra Information to Agent States in GAMMS","text":""},{"location":"agent_state_addition/#introduction","title":"Introduction","text":"<p>GAMMS allows you to pass custom information to agents via their state. This feature is particularly useful for enhancing agent strategies with contextual or dynamic data. In this guide, you'll learn how to: 1. Add extra information to an agent's state. 2. Use that information in the agent's strategy. 3. Dynamically update state information during the simulation.</p>"},{"location":"agent_state_addition/#adding-extra-information-to-agent-state","title":"Adding Extra Information to Agent State","text":"<p>You can pass custom variables to an agent's state by using the <code>state.update()</code> method. This can be done during each simulation step. This information can then be accessed to create your strategy.</p>"},{"location":"agent_state_addition/#example-adding-custom-variables-to-state","title":"Example: Adding Custom Variables to State","text":"<pre><code>for agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Add custom variables to the agent's state\n    state.update({\n        \"food_positions\": [food['x'] for food in remaining_food],  # Node IDs of food\n        \"agent_params\": {\"speed\": 5, \"energy\": 100},               # Custom parameters\n        \"flag_positions\": FLAG_POSITIONS,                         # Example static data\n    })\n\n    # Execute the agent's strategy\n    agent.strategy(state)\n\n    # Update the state back to the agent\n    agent.set_state()\n</code></pre>"},{"location":"agent_state_addition/#dynamically-updating-state-information","title":"Dynamically Updating State Information","text":"<p>State information can also be updated dynamically during the simulation. For example, you might want to update a variable based on changes in the environment.</p>"},{"location":"agent_state_addition/#example-updating-state-based-on-agent-interaction","title":"Example: Updating State Based on Agent Interaction","text":"<pre><code>for agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Example: Update energy level based on movement\n    if state['action']:\n        state['agent_params']['energy'] -= 1\n\n    # Example: Remove a food position if the agent reaches it\n    if state['curr_pos'] in state['food_positions']:\n        state['food_positions'].remove(state['curr_pos'])\n\n    # Execute the agent's strategy\n    agent.strategy(state)\n\n    # Update the state back to the agent\n    agent.set_state()\n</code></pre>"},{"location":"agent_state_addition/#handling-initialization-of-custom-state-variables","title":"Handling Initialization of Custom State Variables","text":"<p>To ensure custom state variables are initialized properly, you can set them during the simulation startup or the first simulation step.</p>"},{"location":"agent_state_addition/#example-initializing-state-variables","title":"Example: Initializing State Variables","text":"<pre><code>for agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Initialize custom variables if they don't exist\n    if 'memory' not in state:\n        state['memory'] = {}  # Initialize memory for tracking visited nodes\n\n    agent.set_state()\n</code></pre>"},{"location":"agent_state_addition/#advanced-use-case-sharing-global-data","title":"Advanced Use Case: Sharing Global Data","text":"<p>Sometimes you might want agents to share global information, such as environmental conditions or the positions of other agents.</p>"},{"location":"agent_state_addition/#example-sharing-global-data-among-agents","title":"Example: Sharing Global Data Among Agents","text":"<pre><code>global_data = {\n    \"temperature\": 25,\n    \"wind_speed\": 10,\n    \"food_locations\": [0, 1, 2, 3],\n}\n\nfor agent in ctx.agent.create_iter():\n    state = agent.get_state()\n\n    # Share global data with agents\n    state.update(global_data)\n\n    agent.strategy(state)\n    agent.set_state()\n</code></pre>"},{"location":"artists/","title":"Using Artists in GAMMS","text":""},{"location":"artists/#introduction","title":"Introduction","text":"<p>In GAMMS, artists are visual elements that can be added to the simulation to enhance visualization. They are typically used to represent objects like resources, obstacles, or any custom markers. This guide explains how to create, customize, and use artists in your GAMMS simulations.</p>"},{"location":"artists/#creating-an-artist","title":"Creating an Artist","text":"<p>Artists are added using the <code>ctx.visual.add_artist()</code> method. This requires you to define: 1. Name: A unique identifier for the artist. 2. Data: A dictionary containing the artist's properties (e.g., position, color, size).</p>"},{"location":"artists/#example-adding-a-circle-artist","title":"Example: Adding a Circle Artist","text":"<p>The following example creates a circle artist to represent a resource on the graph:</p> <pre><code># Define the data for the circle artist\ncircle_data = {\n    'x': 100,            # X-coordinate\n    'y': 200,            # Y-coordinate\n    'scale': 15.0,       # Radius of the circle\n    'color': (255, 0, 0) # RGB color (red)\n}\n\n# Add the circle artist to the visualization\nctx.visual.add_artist('resource_node', circle_data)\n</code></pre>"},{"location":"artists/#updating-artists-dynamically","title":"Updating Artists Dynamically","text":"<p>Artists can be updated dynamically during the simulation to reflect changes in the environment. For example, you can move a circle to a new position or change its color.</p>"},{"location":"artists/#example-updating-an-artists-position","title":"Example: Updating an Artist's Position","text":"<pre><code># Update the position of an artist\ncircle_data['x'] = 150  # New X-coordinate\ncircle_data['y'] = 250  # New Y-coordinate\n\n# Re-add or update the artist\nctx.visual.add_artist('resource_node', circle_data)\n</code></pre>"},{"location":"artists/#removing-an-artist","title":"Removing an Artist","text":"<p>To remove an artist, use the <code>ctx.visual.remove_artist()</code> method with the name of the artist:</p> <pre><code># Remove the circle artist\nctx.visual.remove_artist('resource_node')\n</code></pre>"},{"location":"artists/#customizing-artists","title":"Customizing Artists","text":"<p>Artists can be customized with additional properties to represent various objects in the simulation. Below are some common customizations:</p> <ol> <li>Shape:</li> <li> <p>Circles (<code>pygame.draw.circle</code>) are the default, but you can create custom shapes by extending the artist logic.</p> </li> <li> <p>Color:</p> </li> <li> <p>Use RGB tuples like <code>(255, 0, 0)</code> for red, <code>(0, 255, 0)</code> for green, etc.</p> </li> <li> <p>Size:</p> </li> <li> <p>The <code>scale</code> property defines the size of the artist (e.g., the radius of a circle).</p> </li> <li> <p>Dynamic Properties:</p> </li> <li>Pass any extra data into the <code>data</code> dictionary for custom rendering logic.</li> </ol>"},{"location":"artists/#advanced-example-highlighting-nodes-dynamically","title":"Advanced Example: Highlighting Nodes Dynamically","text":"<p>In this example, we use artists to highlight nodes as agents visit them:</p> <pre><code>visited_nodes = set()\n\nwhile not ctx.is_terminated():\n    for agent in ctx.agent.create_iter():\n        current_node = agent.current_node_id\n        if current_node not in visited_nodes:\n            visited_nodes.add(current_node)\n\n            # Create a circle to highlight the visited node\n            highlight_data = {\n                'x': ctx.graph.graph.get_node(current_node).x,\n                'y': ctx.graph.graph.get_node(current_node).y,\n                'scale': 10.0,\n                'color': (0, 255, 0)  # Green color for visited nodes\n            }\n            ctx.visual.add_artist(f'visited_node_{current_node}', highlight_data)\n</code></pre>"},{"location":"context/","title":"GAMMS Context","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing the overall context of the system.</p> <p>The <code>IContext</code> interface serves as a central point of access to various engine components within the system, including sensors, visualization, agents, and graph management. It provides properties to retrieve instances of these engines, facilitating coordinated interactions and data flow between different system parts.</p>"},{"location":"context/#gamms.typing.IContext.agent","title":"<code>agent</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the agent engine.</p> <p>The agent engine manages the lifecycle and behavior of agents within the system. It handles agent creation, state management, and interaction with other system components.</p> <p>Returns:</p> Name Type Description <code>IAgentEngine</code> <code>IAgentEngine</code> <p>An instance of the agent engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the agent engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.graph","title":"<code>graph</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the graph engine.</p> <p>The graph engine manages the underlying graph structure, including nodes and edges. It provides functionalities to modify the graph, retrieve graph elements, and maintain graph integrity.</p> <p>Returns:</p> Name Type Description <code>IGraphEngine</code> <code>IGraphEngine</code> <p>An instance of the graph engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the graph engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.ictx","title":"<code>ictx</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the internal context of the system.</p> <p>The internal context encapsulates core configurations, state information, and shared resources necessary for the operation of various system components.</p> <p>Returns:</p> Name Type Description <code>IInternalContext</code> <code>IInternalContext</code> <p>An instance representing the internal context.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the internal context is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.logger","title":"<code>logger</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the logger.</p> <p>The logger is responsible for logging messages and events within the system. It provides various logging levels (debug, info, warning, error, critical) for structured logging.</p> <p>Returns:</p> Name Type Description <code>ILogger</code> <code>ILogger</code> <p>An instance of the logger engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the logger engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.record","title":"<code>record</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the recorder.</p> <p>The recorder is responsible for recording and replaying system events. It captures information about system states and interactions for analysis and debugging purposes.</p> <p>Returns:</p> Name Type Description <code>IRecorder</code> <code>IRecorder</code> <p>An instance of the recorder engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the recorder engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.sensor","title":"<code>sensor</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the sensor engine.</p> <p>The sensor engine manages all sensor-related operations, including the creation, updating, and retrieval of sensors. It facilitates data collection from various sources within the system.</p> <p>Returns:</p> Name Type Description <code>ISensorEngine</code> <code>ISensorEngine</code> <p>An instance of the sensor engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the sensor engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.visual","title":"<code>visual</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieve the visualization engine.</p> <p>The visualization engine handles the rendering and display of the system's graphical elements, such as graphs and agents. It manages visual configurations and updates the visualization based on simulation states.</p> <p>Returns:</p> Name Type Description <code>IVisualizationEngine</code> <code>IVisualizationEngine</code> <p>An instance of the visualization engine.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the visualization engine is not properly initialized.</p>"},{"location":"context/#gamms.typing.IContext.is_terminated","title":"<code>is_terminated()</code>  <code>abstractmethod</code>","text":"<p>Check if the context is terminated.</p> <p>This method determines whether the context has been terminated, indicating that no further operations should be performed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the context is terminated, False otherwise.</p>"},{"location":"context/#gamms.typing.IContext.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the context.</p> <p>This method performs necessary cleanup operations and releases resources associated with the context. It should be called when the context is no longer needed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the termination process encounters an error.</p>"},{"location":"first_game/","title":"Programming Your First GAMMS Game","text":""},{"location":"first_game/#introduction","title":"Introduction","text":"<p>This case study walks through setting up a GAMMS game from scratch. By following this guide, you will:</p> <p>\u2705 Configure a graph-based environment using <code>config.py</code>. \u2705 Implement agent strategies in <code>blue_strategy.py</code> (human-controlled) and <code>red_strategy.py</code> (AI-controlled). \u2705 Run the game simulation using <code>game.py</code>.  </p> <p>By the end, you'll have a working adversarial simulation where agents interact in a structured environment.</p>"},{"location":"first_game/#step-1-configuring-the-game-configpy","title":"Step 1: Configuring the Game (<code>config.py</code>)","text":"<p>The <code>config.py</code> file sets up the game environment, including: - Graph settings - Agent configurations - Sensor definitions - Visualization settings </p>"},{"location":"first_game/#configuration-code","title":"Configuration Code","text":"<pre><code>import gamms\n\n# Visualization Engine\nvis_engine = gamms.visual.Engine.PYGAME\n\n# Graph Configuration\nlocation = \"Sample Area\"\nresolution = 100.0\ngraph_path = 'graph.pkl'\n\n# Sensor Configuration\nsensor_config = {\n    'neigh_0': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_1': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_2': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_3': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_4': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_5': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_6': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_7': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_8': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'neigh_9': {'type': gamms.sensor.SensorType.NEIGHBOR},\n    'map': {'type': gamms.sensor.SensorType.MAP},\n    'agent': {'type': gamms.sensor.SensorType.AGENT},\n}\n\n# Agent Configuration For Two Teams\nagent_config = {\n    'agent_0': {'meta': {'team': 0}, 'sensors': ['neigh_0', 'map', 'agent'], 'start_node_id': 0},\n    'agent_1': {'meta': {'team': 0}, 'sensors': ['neigh_1', 'map', 'agent'], 'start_node_id': 1},\n    'agent_2': {'meta': {'team': 0}, 'sensors': ['neigh_2', 'map', 'agent'], 'start_node_id': 2},\n    'agent_3': {'meta': {'team': 0}, 'sensors': ['neigh_3', 'map', 'agent'], 'start_node_id': 3},\n    'agent_4': {'meta': {'team': 0}, 'sensors': ['neigh_4', 'map', 'agent'], 'start_node_id': 4},\n    'agent_5': {'meta': {'team': 1}, 'sensors': ['neigh_5', 'map', 'agent'], 'start_node_id': 500},\n    'agent_6': {'meta': {'team': 1}, 'sensors': ['neigh_6', 'map', 'agent'], 'start_node_id': 501},\n    'agent_7': {'meta': {'team': 1}, 'sensors': ['neigh_7', 'map', 'agent'], 'start_node_id': 502},\n    'agent_8': {'meta': {'team': 1}, 'sensors': ['neigh_8', 'map', 'agent'], 'start_node_id': 503},\n    'agent_9': {'meta': {'team': 1}, 'sensors': ['neigh_9', 'map', 'agent'], 'start_node_id': 504},\n}\n\n# Visualization Configuration\ngraph_vis_config = {'width': 1980, 'height': 1080}\n\nagent_vis_config = {\n    **{f'agent_{i}': {'color': 'blue', 'size': 8} for i in range(0, 5)},  # Blue Team\n    **{f'agent_{i}': {'color': 'red', 'size': 8} for i in range(500, 505)},  # Red Team\n}\n</code></pre>"},{"location":"first_game/#step-2-implementing-agent-behavior","title":"Step 2: Implementing Agent Behavior","text":"<p>Each team follows a different strategy: - Blue agents are human-controlled (no AI strategy). - Red agents use AI for movement decisions.  </p>"},{"location":"first_game/#blue-strategy-blue_strategypy","title":"Blue Strategy (<code>blue_strategy.py</code>)","text":"<p>Since Blue agents are human-controlled, we do not assign them an AI strategy.</p> <pre><code>def map_strategy(agent_config):\n    return {}  # No AI strategy for human-controlled players\n</code></pre>"},{"location":"first_game/#red-strategy-red_strategypy","title":"Red Strategy (<code>red_strategy.py</code>)","text":"<p>Red agents follow a random movement strategy, choosing a neighboring node at each turn.</p> <pre><code>import random\nfrom gamms import sensor\n\ndef strategy(state):\n    sensor_data = state['sensor']\n    for (sensor_type, neighbors) in sensor_data.values():\n        if sensor_type == sensor.SensorType.NEIGHBOR:\n            state['action'] = random.choice(neighbors)\n            break\n\ndef map_strategy(agent_config):\n    return {name: strategy for name in agent_config.keys()}\n</code></pre>"},{"location":"first_game/#step-3-running-the-simulation-gamepy","title":"Step 3: Running the Simulation (<code>game.py</code>)","text":"<p>The <code>game.py</code> script: \u2705 Initializes the game environment. \u2705 Loads the graph-based map. \u2705 Creates and assigns sensors to agents. \u2705 Registers strategies to agents. \u2705 Runs the simulation loop until termination.</p>"},{"location":"first_game/#game-execution-code","title":"Game Execution Code","text":"<pre><code>import gamms\nimport pickle\nfrom config import (\n    vis_engine,\n    graph_path,\n    sensor_config,\n    agent_config,\n    graph_vis_config,\n    agent_vis_config,\n)\nimport blue_strategy\nimport red_strategy\n\n# Create the game context\nctx = gamms.create_context(vis_engine=vis_engine)\n\n# Load the graph\nwith open(graph_path, 'rb') as f:\n    G = pickle.load(f)\n\nctx.graph.attach_networkx_graph(G)\n\n# Create the sensors\nfor name, sensor in sensor_config.items():\n    ctx.sensor.create_sensor(name, sensor['type'], **sensor.get('args', {}))\n\n# Create the agents\nfor name, agent in agent_config.items():\n    ctx.agent.create_agent(name, **agent)\n\n# Assign strategies: Blue is human-controlled, Red has AI\nstrategies = red_strategy.map_strategy(agent_config)\n\n# Register strategies for agents\nfor agent in ctx.agent.create_iter():\n    agent.register_strategy(strategies.get(agent.name, None))  # Blue agents get None (manual control)\n\n# Set visualization configurations\nctx.visual.set_graph_visual(**graph_vis_config)\n\nfor name, config in agent_vis_config.items():\n    ctx.visual.set_agent_visual(name, **config)\n\n#Termination Condition\nturn_count = 0\n\ndef rule_terminate(ctx):\n    global turn_count\n    turn_count += 1\n    if turn_count &gt; 100:\n        ctx.terminate()\n\n# Run the simulation\nwhile not ctx.is_terminated():\n    for agent in ctx.agent.create_iter():\n        if agent.strategy is not None:\n            agent.step()  # AI-controlled agent moves\n        else:\n            state = agent.get_state()\n            node = ctx.visual.human_input(agent.name, state)  # Human-controlled input\n            state['action'] = node\n            agent.set_state()\n\n    # Update visualization\n    ctx.visual.simulate()\n    rule_terminate(ctx)\n</code></pre>"},{"location":"first_game/#conclusion","title":"Conclusion","text":"<p>By following this structured approach, we successfully implemented a basic adversarial game in GAMMS. We: \u2705 Defined a graph-based environment for agents to explore. \u2705 Implemented human-controlled (Blue) and AI-controlled (Red) agents. \u2705 Ran a game simulation with interactive visualization.  </p> <p>Want to extend this? Try: \u2705 Creating an AI-controlled Blue Team for training scenarios. \u2705 Adding new sensor types for richer decision-making. \u2705 Implementing custom agent behaviors beyond random movement.  </p> <p>Start modifying your game today! \ud83d\ude80</p>"},{"location":"graph/","title":"Graph Engine","text":""},{"location":"graph/#gamms.typing.graph_engine.Engine","title":"<code>Engine</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing different types of graph engines.</p> <p>Attributes:</p> Name Type Description <code>MEMORY</code> <p>In-memory graph engine.</p> <code>SQLITE</code> <p>SQLite-based graph engine.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>class Engine(Enum):\n    \"\"\"\n    Enum representing different types of graph engines.\n\n    Attributes:\n        MEMORY: In-memory graph engine.\n        SQLITE: SQLite-based graph engine.        \n    \"\"\"\n    MEMORY = 0\n    SQLITE = 1\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph","title":"<code>IGraph</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a graph structure.</p> <p>The graph consists of nodes and edges, allowing for addition, removal, and retrieval of these elements.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>class IGraph(ABC):\n    \"\"\"\n    Abstract base class representing a graph structure.\n\n    The graph consists of nodes and edges, allowing for addition, removal, and retrieval of these elements.\n    \"\"\"\n\n    @abstractmethod\n    def add_node(self, node_data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Add a new node to the graph.\n\n        Args:\n            node_data (Dict[str, Any]): A dictionary containing the node's attributes. Expected keys include:\n                - 'id' (int): Unique identifier for the node.\n                - 'x' (float): X-coordinate of the node.\n                - 'y' (float): Y-coordinate of the node.\n\n        Raises:\n            ValueError: If the node_data is missing required fields or contains invalid data.\n            KeyError: If a node with the same ID already exists in the graph.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_edge(self, edge_data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Add a new edge to the graph.\n\n        Args:\n            edge_data (Dict[str, Any]): A dictionary containing the edge's attributes. Expected keys include:\n                - 'id' (int): Unique identifier for the edge.\n                - 'source' (int): ID of the source node.\n                - 'target' (int): ID of the target node.\n                - 'length' (float): Length of the edge.\n                - 'linestring' (List[Tuple[float, float]], optional): Geometry of the edge.\n\n        Raises:\n            ValueError: If the edge_data is missing required fields, contains invalid data, or references non-existent nodes.\n            KeyError: If an edge with the same ID already exists in the graph.\n            KeyError: If source or target nodes do not exist in the graph.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @overload\n    def get_nodes(self) -&gt; Iterator[int]:\n        \"\"\"\n        Creates an iterator of node IDs in the graph.\n\n        Returns:\n            Iterator[int]: An iterator that yields node IDs.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @overload\n    def get_nodes(self, d: float, x: float, y: float) -&gt; Iterator[int]:\n        \"\"\"\n        Creates an iterator of node IDs in the graph.\n\n        If d is non-negative, it returns nodes within a distance d from the point (x, y).\n        May return nodes that are farther than d but will always return nodes that are within d.\n\n        Returns:\n            Iterator[int]: An iterator that yields node IDs.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @overload\n    def get_edges(self) -&gt; Iterator[int]:\n        \"\"\"\n        Creates an iterator of edge IDs in the graph.\n\n        Returns:\n            Iterator[int]: An iterator that yields edge IDs.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @overload\n    def get_edges(self, d: float, x: float, y: float) -&gt; Iterator[int]:\n        \"\"\"\n        Creates an iterator of edge IDs in the graph.\n        If d is non-negative, it returns edges within a distance d from the point (x, y).\n        May return edges that are farther than d but will always return edges that are within d.\n\n        \"Within\" means that atleast one of the edge's nodes is within distance d from the point (x, y).\n\n        Returns:\n            Iterator[int]: An iterator that yields edge IDs.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_node(self, node_data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update an existing node's attributes.\n\n        Args:\n            node_data (Dict[str, Any]): A dictionary containing the node's updated attributes. Must include:\n                - 'id' (int): Unique identifier for the node.\n                - Any other attributes to be updated (e.g., 'x', 'y').\n\n        Raises:\n            KeyError: If the node with the specified ID does not exist.\n            ValueError: If the provided data is invalid.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_edge(self, edge_data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update an existing edge's attributes.\n\n        Args:\n            edge_data (Dict[str, Any]): A dictionary containing the edge's updated attributes. Must include:\n                - 'id' (int): Unique identifier for the edge.\n                - Any other attributes to be updated (e.g., 'source', 'target', 'length', 'linestring').\n\n        Raises:\n            KeyError: If the edge with the specified ID does not exist.\n            ValueError: If the provided data is invalid or references non-existent nodes.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_node(self, node_id: int) -&gt; None:\n        \"\"\"\n        Remove a node from the graph. Removing a node will also remove all edges connected to it.\n\n        Args:\n            node_id (int): The unique identifier of the node to be removed.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_edge(self, edge_id: int) -&gt; None:\n        \"\"\"\n        Remove an edge from the graph.\n\n        Args:\n            edge_id (int): The unique identifier of the edge to be removed.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_node(self, node_id: int) -&gt; Node:\n        \"\"\"\n        Retrieve the attributes of a specific node.\n\n        Args:\n            node_id (int): The unique identifier of the node to retrieve.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing the node's attributes.\n\n        Raises:\n            KeyError: If the node with the specified ID does not exist.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_edge(self, edge_id: int) -&gt; OSMEdge:\n        \"\"\"\n        Retrieve the attributes of a specific edge.\n\n        Args:\n            edge_id (int): The unique identifier of the edge to retrieve.\n\n        Returns:\n            OSMEdge: A dictionary containing the edge's attributes.\n\n        Raises:\n            KeyError: If the edge with the specified ID does not exist.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_neighbors(self, node_id: int) -&gt; Iterator[int]:\n        \"\"\"\n        Get the neighbors of a specific node.\n\n        Args:\n            node_id (int): The unique identifier of the node whose neighbors are to be retrieved.\n\n        Returns:\n            Iterator[int]: An iterator that yields the IDs of neighboring nodes.\n\n        Raises:\n            KeyError: If the node with the specified ID does not exist.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.add_edge","title":"<code>add_edge(edge_data)</code>  <code>abstractmethod</code>","text":"<p>Add a new edge to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the edge's attributes. Expected keys include: - 'id' (int): Unique identifier for the edge. - 'source' (int): ID of the source node. - 'target' (int): ID of the target node. - 'length' (float): Length of the edge. - 'linestring' (List[Tuple[float, float]], optional): Geometry of the edge.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the edge_data is missing required fields, contains invalid data, or references non-existent nodes.</p> <code>KeyError</code> <p>If an edge with the same ID already exists in the graph.</p> <code>KeyError</code> <p>If source or target nodes do not exist in the graph.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef add_edge(self, edge_data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Add a new edge to the graph.\n\n    Args:\n        edge_data (Dict[str, Any]): A dictionary containing the edge's attributes. Expected keys include:\n            - 'id' (int): Unique identifier for the edge.\n            - 'source' (int): ID of the source node.\n            - 'target' (int): ID of the target node.\n            - 'length' (float): Length of the edge.\n            - 'linestring' (List[Tuple[float, float]], optional): Geometry of the edge.\n\n    Raises:\n        ValueError: If the edge_data is missing required fields, contains invalid data, or references non-existent nodes.\n        KeyError: If an edge with the same ID already exists in the graph.\n        KeyError: If source or target nodes do not exist in the graph.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.add_node","title":"<code>add_node(node_data)</code>  <code>abstractmethod</code>","text":"<p>Add a new node to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the node's attributes. Expected keys include: - 'id' (int): Unique identifier for the node. - 'x' (float): X-coordinate of the node. - 'y' (float): Y-coordinate of the node.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node_data is missing required fields or contains invalid data.</p> <code>KeyError</code> <p>If a node with the same ID already exists in the graph.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef add_node(self, node_data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Add a new node to the graph.\n\n    Args:\n        node_data (Dict[str, Any]): A dictionary containing the node's attributes. Expected keys include:\n            - 'id' (int): Unique identifier for the node.\n            - 'x' (float): X-coordinate of the node.\n            - 'y' (float): Y-coordinate of the node.\n\n    Raises:\n        ValueError: If the node_data is missing required fields or contains invalid data.\n        KeyError: If a node with the same ID already exists in the graph.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.get_edge","title":"<code>get_edge(edge_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the attributes of a specific edge.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>int</code> <p>The unique identifier of the edge to retrieve.</p> required <p>Returns:</p> Name Type Description <code>OSMEdge</code> <code>OSMEdge</code> <p>A dictionary containing the edge's attributes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge with the specified ID does not exist.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef get_edge(self, edge_id: int) -&gt; OSMEdge:\n    \"\"\"\n    Retrieve the attributes of a specific edge.\n\n    Args:\n        edge_id (int): The unique identifier of the edge to retrieve.\n\n    Returns:\n        OSMEdge: A dictionary containing the edge's attributes.\n\n    Raises:\n        KeyError: If the edge with the specified ID does not exist.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.get_neighbors","title":"<code>get_neighbors(node_id)</code>  <code>abstractmethod</code>","text":"<p>Get the neighbors of a specific node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node whose neighbors are to be retrieved.</p> required <p>Returns:</p> Type Description <code>Iterator[int]</code> <p>Iterator[int]: An iterator that yields the IDs of neighboring nodes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the node with the specified ID does not exist.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef get_neighbors(self, node_id: int) -&gt; Iterator[int]:\n    \"\"\"\n    Get the neighbors of a specific node.\n\n    Args:\n        node_id (int): The unique identifier of the node whose neighbors are to be retrieved.\n\n    Returns:\n        Iterator[int]: An iterator that yields the IDs of neighboring nodes.\n\n    Raises:\n        KeyError: If the node with the specified ID does not exist.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.get_node","title":"<code>get_node(node_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the attributes of a specific node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to retrieve.</p> required <p>Returns:</p> Type Description <code>Node</code> <p>Dict[str, Any]: A dictionary containing the node's attributes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the node with the specified ID does not exist.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef get_node(self, node_id: int) -&gt; Node:\n    \"\"\"\n    Retrieve the attributes of a specific node.\n\n    Args:\n        node_id (int): The unique identifier of the node to retrieve.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the node's attributes.\n\n    Raises:\n        KeyError: If the node with the specified ID does not exist.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.remove_edge","title":"<code>remove_edge(edge_id)</code>  <code>abstractmethod</code>","text":"<p>Remove an edge from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>int</code> <p>The unique identifier of the edge to be removed.</p> required Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef remove_edge(self, edge_id: int) -&gt; None:\n    \"\"\"\n    Remove an edge from the graph.\n\n    Args:\n        edge_id (int): The unique identifier of the edge to be removed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.remove_node","title":"<code>remove_node(node_id)</code>  <code>abstractmethod</code>","text":"<p>Remove a node from the graph. Removing a node will also remove all edges connected to it.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to be removed.</p> required Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph. Removing a node will also remove all edges connected to it.\n\n    Args:\n        node_id (int): The unique identifier of the node to be removed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.update_edge","title":"<code>update_edge(edge_data)</code>  <code>abstractmethod</code>","text":"<p>Update an existing edge's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>edge_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the edge's updated attributes. Must include: - 'id' (int): Unique identifier for the edge. - Any other attributes to be updated (e.g., 'source', 'target', 'length', 'linestring').</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the edge with the specified ID does not exist.</p> <code>ValueError</code> <p>If the provided data is invalid or references non-existent nodes.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef update_edge(self, edge_data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update an existing edge's attributes.\n\n    Args:\n        edge_data (Dict[str, Any]): A dictionary containing the edge's updated attributes. Must include:\n            - 'id' (int): Unique identifier for the edge.\n            - Any other attributes to be updated (e.g., 'source', 'target', 'length', 'linestring').\n\n    Raises:\n        KeyError: If the edge with the specified ID does not exist.\n        ValueError: If the provided data is invalid or references non-existent nodes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraph.update_node","title":"<code>update_node(node_data)</code>  <code>abstractmethod</code>","text":"<p>Update an existing node's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>node_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the node's updated attributes. Must include: - 'id' (int): Unique identifier for the node. - Any other attributes to be updated (e.g., 'x', 'y').</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the node with the specified ID does not exist.</p> <code>ValueError</code> <p>If the provided data is invalid.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef update_node(self, node_data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update an existing node's attributes.\n\n    Args:\n        node_data (Dict[str, Any]): A dictionary containing the node's updated attributes. Must include:\n            - 'id' (int): Unique identifier for the node.\n            - Any other attributes to be updated (e.g., 'x', 'y').\n\n    Raises:\n        KeyError: If the node with the specified ID does not exist.\n        ValueError: If the provided data is invalid.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraphEngine","title":"<code>IGraphEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing the graph engine.</p> <p>The graph engine manages the underlying graph structure, providing access and control over graph operations.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>class IGraphEngine(ABC):\n    \"\"\"\n    Abstract base class representing the graph engine.\n\n    The graph engine manages the underlying graph structure, providing access and control over graph operations.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def graph(self) -&gt; IGraph:\n        \"\"\"\n        Get the current graph managed by the engine.\n\n        Returns:\n            IGraph: The graph instance being managed.\n\n        Raises:\n            RuntimeError: If the graph has not been initialized.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def attach_networkx_graph(self, G: nx.Graph) -&gt; IGraph:\n        \"\"\"\n        Attach a NetworkX graph to the graph engine.\n\n        Args:\n            G (nx.Graph): The NetworkX graph to attach.\n\n        Returns:\n            IGraph: The graph instance created from the NetworkX graph.\n\n        Raises:\n            ValueError: If the provided graph is invalid or cannot be attached.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def terminate(self) -&gt; None:\n        \"\"\"\n        Terminate the graph engine and perform necessary cleanup operations.\n\n        This method should ensure that all resources allocated to the graph engine are properly released\n        and that any ongoing operations are gracefully stopped.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraphEngine.graph","title":"<code>graph</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current graph managed by the engine.</p> <p>Returns:</p> Name Type Description <code>IGraph</code> <code>IGraph</code> <p>The graph instance being managed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the graph has not been initialized.</p>"},{"location":"graph/#gamms.typing.graph_engine.IGraphEngine.attach_networkx_graph","title":"<code>attach_networkx_graph(G)</code>  <code>abstractmethod</code>","text":"<p>Attach a NetworkX graph to the graph engine.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The NetworkX graph to attach.</p> required <p>Returns:</p> Name Type Description <code>IGraph</code> <code>IGraph</code> <p>The graph instance created from the NetworkX graph.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided graph is invalid or cannot be attached.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef attach_networkx_graph(self, G: nx.Graph) -&gt; IGraph:\n    \"\"\"\n    Attach a NetworkX graph to the graph engine.\n\n    Args:\n        G (nx.Graph): The NetworkX graph to attach.\n\n    Returns:\n        IGraph: The graph instance created from the NetworkX graph.\n\n    Raises:\n        ValueError: If the provided graph is invalid or cannot be attached.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.IGraphEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the graph engine and perform necessary cleanup operations.</p> <p>This method should ensure that all resources allocated to the graph engine are properly released and that any ongoing operations are gracefully stopped.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>@abstractmethod\ndef terminate(self) -&gt; None:\n    \"\"\"\n    Terminate the graph engine and perform necessary cleanup operations.\n\n    This method should ensure that all resources allocated to the graph engine are properly released\n    and that any ongoing operations are gracefully stopped.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.Node","title":"<code>Node</code>","text":"<p>Represents a node within a graph.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for the node.</p> <code>x</code> <code>float</code> <p>The x-coordinate of the node's position.</p> <code>y</code> <code>float</code> <p>The y-coordinate of the node's position.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>class Node:\n    \"\"\"\n    Represents a node within a graph.\n\n    Attributes:\n        id (int): The unique identifier for the node.\n        x (float): The x-coordinate of the node's position.\n        y (float): The y-coordinate of the node's position.\n    \"\"\"\n    id: int\n    x: float\n    y: float\n</code></pre>"},{"location":"graph/#gamms.typing.graph_engine.OSMEdge","title":"<code>OSMEdge</code>","text":"<p>Represents an OpenStreetMap (OSM) edge within a graph.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for the edge.</p> <code>source</code> <code>int</code> <p>The ID of the source node.</p> <code>target</code> <code>int</code> <p>The ID of the target node.</p> <code>length</code> <code>float</code> <p>The length of the edge.</p> <code>linestring</code> <code>LineString</code> <p>The geometry of the edge represented as a LineString. Defaults to None.</p> Source code in <code>gamms/typing/graph_engine.py</code> <pre><code>class OSMEdge:\n    \"\"\"\n    Represents an OpenStreetMap (OSM) edge within a graph.\n\n    Attributes:\n        id (int): The unique identifier for the edge.\n        source (int): The ID of the source node.\n        target (int): The ID of the target node.\n        length (float): The length of the edge.\n        linestring (LineString): The geometry of the edge represented as a LineString.\n            Defaults to None.\n    \"\"\"\n    id: int\n    source: int  # Node ID\n    target: int  # Node ID\n    length: float\n    linestring: LineString\n</code></pre>"},{"location":"logger/","title":"Logger","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for logging in the system.</p> <p>The <code>ILogger</code> interface defines the structure for logging messages within the system. It provides methods for logging messages at different severity levels, including debug, info, warning, error, and critical.</p> Source code in <code>gamms/typing/logger.py</code> <pre><code>class ILogger(ABC):\n    \"\"\"\n    Abstract base class for logging in the system.\n\n    The `ILogger` interface defines the structure for logging messages within the\n    system. It provides methods for logging messages at different severity levels,\n    including debug, info, warning, error, and critical.\n    \"\"\"\n\n    @abstractmethod\n    def debug(self, msg: str) -&gt; None:\n        \"\"\"\n        Log a debug message.\n\n        Args:\n            msg (str): The debug message to log.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def info(self, msg: str) -&gt; None:\n        \"\"\"\n        Log an informational message.\n\n        Args:\n            msg (str): The informational message to log.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def warning(self, msg: str) -&gt; None:\n        \"\"\"\n        Log a warning message.\n\n        Args:\n            msg (str): The warning message to log.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def error(self, msg: str) -&gt; None:\n        \"\"\"\n        Log an error message.\n\n        Args:\n            msg (str): The error message to log.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def critical(self, msg: str) -&gt; None:\n        \"\"\"\n        Log a critical message.\n\n        Args:\n            msg (str): The critical message to log.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def setLevel(self, level: int) -&gt; None:\n        \"\"\"\n        Set the logging level.\n\n        Args:\n            level (str): The logging level to set (e.g., 'DEBUG', 'INFO', 'WARNING', 'ERROR').\n        \"\"\"\n        pass\n</code></pre>"},{"location":"logger/#gamms.typing.ILogger.critical","title":"<code>critical(msg)</code>  <code>abstractmethod</code>","text":"<p>Log a critical message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The critical message to log.</p> required Source code in <code>gamms/typing/logger.py</code> <pre><code>@abstractmethod\ndef critical(self, msg: str) -&gt; None:\n    \"\"\"\n    Log a critical message.\n\n    Args:\n        msg (str): The critical message to log.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"logger/#gamms.typing.ILogger.debug","title":"<code>debug(msg)</code>  <code>abstractmethod</code>","text":"<p>Log a debug message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The debug message to log.</p> required Source code in <code>gamms/typing/logger.py</code> <pre><code>@abstractmethod\ndef debug(self, msg: str) -&gt; None:\n    \"\"\"\n    Log a debug message.\n\n    Args:\n        msg (str): The debug message to log.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"logger/#gamms.typing.ILogger.error","title":"<code>error(msg)</code>  <code>abstractmethod</code>","text":"<p>Log an error message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message to log.</p> required Source code in <code>gamms/typing/logger.py</code> <pre><code>@abstractmethod\ndef error(self, msg: str) -&gt; None:\n    \"\"\"\n    Log an error message.\n\n    Args:\n        msg (str): The error message to log.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"logger/#gamms.typing.ILogger.info","title":"<code>info(msg)</code>  <code>abstractmethod</code>","text":"<p>Log an informational message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The informational message to log.</p> required Source code in <code>gamms/typing/logger.py</code> <pre><code>@abstractmethod\ndef info(self, msg: str) -&gt; None:\n    \"\"\"\n    Log an informational message.\n\n    Args:\n        msg (str): The informational message to log.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"logger/#gamms.typing.ILogger.setLevel","title":"<code>setLevel(level)</code>  <code>abstractmethod</code>","text":"<p>Set the logging level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>The logging level to set (e.g., 'DEBUG', 'INFO', 'WARNING', 'ERROR').</p> required Source code in <code>gamms/typing/logger.py</code> <pre><code>@abstractmethod\ndef setLevel(self, level: int) -&gt; None:\n    \"\"\"\n    Set the logging level.\n\n    Args:\n        level (str): The logging level to set (e.g., 'DEBUG', 'INFO', 'WARNING', 'ERROR').\n    \"\"\"\n    pass\n</code></pre>"},{"location":"logger/#gamms.typing.ILogger.warning","title":"<code>warning(msg)</code>  <code>abstractmethod</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log.</p> required Source code in <code>gamms/typing/logger.py</code> <pre><code>@abstractmethod\ndef warning(self, msg: str) -&gt; None:\n    \"\"\"\n    Log a warning message.\n\n    Args:\n        msg (str): The warning message to log.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/","title":"Recorder","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>class IRecorder(ABC):\n    @abstractmethod\n    def record(self) -&gt; bool:\n        \"\"\"\n        Boolean to inform whether game is being recorded or not and ctx is alive\n\n        Returns:\n            bool: True if recording, False otherwise\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self, path: Union[str, BinaryIO]) -&gt; None:\n        \"\"\"\n        Start recording to the path. Raise error if file already exists\n        Adds \".ggr\" extension if not present.\n\n        If path is a file object, it will be used as the file handler.\n\n        Args:\n            path (Union[str, BinaryIO]): Path to record the game.\n\n        Raises:\n            FileExistsError: If the file already exists.\n            TypeError: If the path is not a string or file object.\n        \"\"\"\n        pass\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop recording to the path and close the file handler.\n\n        Raises:\n            RuntimeError: If recording has not started.\n        \"\"\"\n        pass\n    @abstractmethod\n    def pause(self) -&gt; None:\n        \"\"\"\n        Pause the recording process. `self.record()` should return false if paused.  If not started or stopped, give warning.\n        \"\"\"\n        pass\n    @abstractmethod\n    def play(self) -&gt; None:\n        \"\"\"\n        Resume recording if paused. If not started or stopped, give warning.\n        \"\"\"\n        pass\n    @abstractmethod    \n    def replay(self, path: Union[str, BinaryIO]) -&gt; Iterator[Dict[str, Any]]:\n        \"\"\"\n        Checks validity of the file and output an iterator.\n\n        Args:\n            path (Union[str, BinaryIO]): Path to the recording file.\n\n        Returns:\n            Iterator: Iterator to replay the recording.\n\n        Raises:\n            RuntimeError: If replay is already in progress.\n            FileNotFoundError: If the file does not exist.\n            TypeError: If the path is not a string or file object.\n            ValueError: If the file is not a valid recording file or if recording terminated unexpectedly.\n            ValueError: If the version of the file is not supported.\n        \"\"\"\n        pass\n    @abstractmethod\n    def time(self) -&gt; int:\n        \"\"\"\n        Return record time if replaying. Else return the local time `(time.time())` in nano seconds.\n\n        Returns:\n            int: Time in nanoseconds.\n        \"\"\"\n        pass\n    @abstractmethod\n    def write(self, opCode: OpCodes, data: Dict[str, JsonType]) -&gt; None:\n        \"\"\"\n        Write to record buffer if recording. If not recording raise error as it should not happen.\n\n        WARNING: This function should not be required to be called by the user in most cases.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def component(self, struct: Dict[str, Type[_T]]) -&gt; Callable[[Type[_T]], Type[_T]]:\n        \"\"\"\n        Decorator to add a component to the recorder.\n\n        Args:\n            struct (Dict[str, Type[_T]]): Dictionary with component name and type.\n\n        Returns:\n            Callable[[Type[_T]], Type[_T]]: Decorator function.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_component(self, name: str) -&gt; object:\n        \"\"\"\n        Get the component from the name.\n\n        Args:\n            name (str): Name of the component.\n\n        Returns:\n            Type[_T]: Component object.\n\n        Raises:\n            KeyError: If the component is not found.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_component(self, name: str) -&gt; None:\n        \"\"\"\n        Delete the component from the name.\n\n        Args:\n            name (str): Name of the component.\n\n        Raises:\n            KeyError: If the component is not found.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def component_iter(self) -&gt; Iterator[str]:\n        \"\"\"\n        Iterator for the component names.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_component(self, name: str, obj: Type[_T]) -&gt; None:\n        \"\"\"\n        Add a component to the recorder.\n\n        Args:\n            name (str): Name of the component.\n            obj (Type[_T]): Component object.\n\n        Raises:\n            ValueError: If the component already exists.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_component_registered(self, key: Tuple[str, str]) -&gt; bool:\n        \"\"\"\n        Check if the component is registered.\n        Key is (module_name, qualname)\n\n        Args:\n            key (Tuple[str, str]): Key to check.\n\n        Returns:\n            bool: True if registered, False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def unregister_component(self, key: Tuple[str, str]) -&gt; None:\n        \"\"\"\n        Unregister the component.\n        Key is (module_name, qualname)\n\n        Args:\n            key (Tuple[str, str]): Key to unregister.\n\n        Raises:\n            KeyError: If the component is not found.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.add_component","title":"<code>add_component(name, obj)</code>  <code>abstractmethod</code>","text":"<p>Add a component to the recorder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component.</p> required <code>obj</code> <code>Type[_T]</code> <p>Component object.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the component already exists.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef add_component(self, name: str, obj: Type[_T]) -&gt; None:\n    \"\"\"\n    Add a component to the recorder.\n\n    Args:\n        name (str): Name of the component.\n        obj (Type[_T]): Component object.\n\n    Raises:\n        ValueError: If the component already exists.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.component","title":"<code>component(struct)</code>  <code>abstractmethod</code>","text":"<p>Decorator to add a component to the recorder.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>Dict[str, Type[_T]]</code> <p>Dictionary with component name and type.</p> required <p>Returns:</p> Type Description <code>Callable[[Type[_T]], Type[_T]]</code> <p>Callable[[Type[_T]], Type[_T]]: Decorator function.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef component(self, struct: Dict[str, Type[_T]]) -&gt; Callable[[Type[_T]], Type[_T]]:\n    \"\"\"\n    Decorator to add a component to the recorder.\n\n    Args:\n        struct (Dict[str, Type[_T]]): Dictionary with component name and type.\n\n    Returns:\n        Callable[[Type[_T]], Type[_T]]: Decorator function.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.component_iter","title":"<code>component_iter()</code>  <code>abstractmethod</code>","text":"<p>Iterator for the component names.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef component_iter(self) -&gt; Iterator[str]:\n    \"\"\"\n    Iterator for the component names.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.delete_component","title":"<code>delete_component(name)</code>  <code>abstractmethod</code>","text":"<p>Delete the component from the name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the component is not found.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef delete_component(self, name: str) -&gt; None:\n    \"\"\"\n    Delete the component from the name.\n\n    Args:\n        name (str): Name of the component.\n\n    Raises:\n        KeyError: If the component is not found.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.get_component","title":"<code>get_component(name)</code>  <code>abstractmethod</code>","text":"<p>Get the component from the name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component.</p> required <p>Returns:</p> Type Description <code>object</code> <p>Type[_T]: Component object.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the component is not found.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef get_component(self, name: str) -&gt; object:\n    \"\"\"\n    Get the component from the name.\n\n    Args:\n        name (str): Name of the component.\n\n    Returns:\n        Type[_T]: Component object.\n\n    Raises:\n        KeyError: If the component is not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.is_component_registered","title":"<code>is_component_registered(key)</code>  <code>abstractmethod</code>","text":"<p>Check if the component is registered. Key is (module_name, qualname)</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Tuple[str, str]</code> <p>Key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered, False otherwise.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef is_component_registered(self, key: Tuple[str, str]) -&gt; bool:\n    \"\"\"\n    Check if the component is registered.\n    Key is (module_name, qualname)\n\n    Args:\n        key (Tuple[str, str]): Key to check.\n\n    Returns:\n        bool: True if registered, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.pause","title":"<code>pause()</code>  <code>abstractmethod</code>","text":"<p>Pause the recording process. <code>self.record()</code> should return false if paused.  If not started or stopped, give warning.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef pause(self) -&gt; None:\n    \"\"\"\n    Pause the recording process. `self.record()` should return false if paused.  If not started or stopped, give warning.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.play","title":"<code>play()</code>  <code>abstractmethod</code>","text":"<p>Resume recording if paused. If not started or stopped, give warning.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef play(self) -&gt; None:\n    \"\"\"\n    Resume recording if paused. If not started or stopped, give warning.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.record","title":"<code>record()</code>  <code>abstractmethod</code>","text":"<p>Boolean to inform whether game is being recorded or not and ctx is alive</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if recording, False otherwise</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef record(self) -&gt; bool:\n    \"\"\"\n    Boolean to inform whether game is being recorded or not and ctx is alive\n\n    Returns:\n        bool: True if recording, False otherwise\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.replay","title":"<code>replay(path)</code>  <code>abstractmethod</code>","text":"<p>Checks validity of the file and output an iterator.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, BinaryIO]</code> <p>Path to the recording file.</p> required <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator[Dict[str, Any]]</code> <p>Iterator to replay the recording.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If replay is already in progress.</p> <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>TypeError</code> <p>If the path is not a string or file object.</p> <code>ValueError</code> <p>If the file is not a valid recording file or if recording terminated unexpectedly.</p> <code>ValueError</code> <p>If the version of the file is not supported.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod    \ndef replay(self, path: Union[str, BinaryIO]) -&gt; Iterator[Dict[str, Any]]:\n    \"\"\"\n    Checks validity of the file and output an iterator.\n\n    Args:\n        path (Union[str, BinaryIO]): Path to the recording file.\n\n    Returns:\n        Iterator: Iterator to replay the recording.\n\n    Raises:\n        RuntimeError: If replay is already in progress.\n        FileNotFoundError: If the file does not exist.\n        TypeError: If the path is not a string or file object.\n        ValueError: If the file is not a valid recording file or if recording terminated unexpectedly.\n        ValueError: If the version of the file is not supported.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.start","title":"<code>start(path)</code>  <code>abstractmethod</code>","text":"<p>Start recording to the path. Raise error if file already exists Adds \".ggr\" extension if not present.</p> <p>If path is a file object, it will be used as the file handler.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, BinaryIO]</code> <p>Path to record the game.</p> required <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file already exists.</p> <code>TypeError</code> <p>If the path is not a string or file object.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef start(self, path: Union[str, BinaryIO]) -&gt; None:\n    \"\"\"\n    Start recording to the path. Raise error if file already exists\n    Adds \".ggr\" extension if not present.\n\n    If path is a file object, it will be used as the file handler.\n\n    Args:\n        path (Union[str, BinaryIO]): Path to record the game.\n\n    Raises:\n        FileExistsError: If the file already exists.\n        TypeError: If the path is not a string or file object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop recording to the path and close the file handler.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If recording has not started.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop recording to the path and close the file handler.\n\n    Raises:\n        RuntimeError: If recording has not started.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.time","title":"<code>time()</code>  <code>abstractmethod</code>","text":"<p>Return record time if replaying. Else return the local time <code>(time.time())</code> in nano seconds.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Time in nanoseconds.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef time(self) -&gt; int:\n    \"\"\"\n    Return record time if replaying. Else return the local time `(time.time())` in nano seconds.\n\n    Returns:\n        int: Time in nanoseconds.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.unregister_component","title":"<code>unregister_component(key)</code>  <code>abstractmethod</code>","text":"<p>Unregister the component. Key is (module_name, qualname)</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Tuple[str, str]</code> <p>Key to unregister.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the component is not found.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef unregister_component(self, key: Tuple[str, str]) -&gt; None:\n    \"\"\"\n    Unregister the component.\n    Key is (module_name, qualname)\n\n    Args:\n        key (Tuple[str, str]): Key to unregister.\n\n    Raises:\n        KeyError: If the component is not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"record/#gamms.typing.IRecorder.write","title":"<code>write(opCode, data)</code>  <code>abstractmethod</code>","text":"<p>Write to record buffer if recording. If not recording raise error as it should not happen.</p> <p>WARNING: This function should not be required to be called by the user in most cases.</p> Source code in <code>gamms/typing/recorder.py</code> <pre><code>@abstractmethod\ndef write(self, opCode: OpCodes, data: Dict[str, JsonType]) -&gt; None:\n    \"\"\"\n    Write to record buffer if recording. If not recording raise error as it should not happen.\n\n    WARNING: This function should not be required to be called by the user in most cases.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/","title":"Sensor Engine","text":""},{"location":"sensor/#gamms.typing.sensor_engine.ISensor","title":"<code>ISensor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a generic sensor.</p> <p>Sensors are responsible for collecting data related to specific aspects of the system. Each sensor has a type and maintains its own data state.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>SensorType</code> <p>The type of the sensor.</p> <code>data</code> <code>Dict[str, Any]</code> <p>The data collected or maintained by the sensor.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>class ISensor(ABC):\n    \"\"\"\n    Abstract base class representing a generic sensor.\n\n    Sensors are responsible for collecting data related to specific aspects of the system.\n    Each sensor has a type and maintains its own data state.\n\n    Attributes:\n        type (SensorType): The type of the sensor.\n        data (Dict[str, Any]): The data collected or maintained by the sensor.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def sensor_id(self) -&gt; str:\n        \"\"\"\n        Get the unique identifier of the sensor.\n\n        Returns:\n            str: The unique identifier of the sensor.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def type(self) -&gt; SensorType:\n        \"\"\"\n        Get the type of the sensor.\n\n        Returns:\n            SensorType: The type of the sensor.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def data(self) -&gt; Union[Dict[str, Any], List[int]]:\n        \"\"\"\n        Get the current data maintained by the sensor.\n\n        Returns:\n            Dict[str, Any]: The data maintained by the sensor.\n            List[int]: A list of node identifiers for the NEIGHBOR sensor type.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def sense(self, node_id: int) -&gt; None:\n        \"\"\"\n        Perform sensing operations for a given node.\n\n        This method collects data related to the specified node and returns the sensed information.\n\n        Args:\n            node_id (int): The unique identifier of the node to sense.\n\n        Sensed Data type:\n            Dict[str, Any]: A dictionary containing the sensed data.\n            Only Neigbor sensor returns a list of node ids. List[int]\n\n        Raises:\n            ValueError: If the provided node_id is invalid.\n            RuntimeError: If the sensing operation fails due to system constraints.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update the sensor's data.\n\n        This method modifies the sensor's internal data based on the provided information.\n\n        Args:\n            data (Dict[str, Any]): A dictionary containing the data to update the sensor with.\n\n        Raises:\n            KeyError: If the provided data contains invalid keys.\n            ValueError: If the provided data is malformed or incomplete.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_owner(self, owner: Union[str, None]) -&gt; None:\n        \"\"\"\n        Set the owner of the sensor. Owner is a string that identifies the entity responsible for the sensor.\n        Used for setting the owning agent.\n\n        This method assigns a specific owner to the sensor, which can be used for identification\n        or management purposes.\n\n        Args:\n            owner (str or None): The name of the owner to assign to the sensor.\n\n        Raises:\n            TypeError: If the provided owner is not a string.\n            ValueError: If the provided owner is invalid or empty.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensor.data","title":"<code>data</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current data maintained by the sensor.</p> <p>Returns:</p> Type Description <code>Union[Dict[str, Any], List[int]]</code> <p>Dict[str, Any]: The data maintained by the sensor.</p> <code>Union[Dict[str, Any], List[int]]</code> <p>List[int]: A list of node identifiers for the NEIGHBOR sensor type.</p>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensor.sensor_id","title":"<code>sensor_id</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the unique identifier of the sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier of the sensor.</p>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensor.type","title":"<code>type</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the type of the sensor.</p> <p>Returns:</p> Name Type Description <code>SensorType</code> <code>SensorType</code> <p>The type of the sensor.</p>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensor.sense","title":"<code>sense(node_id)</code>  <code>abstractmethod</code>","text":"<p>Perform sensing operations for a given node.</p> <p>This method collects data related to the specified node and returns the sensed information.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>The unique identifier of the node to sense.</p> required Sensed Data type <p>Dict[str, Any]: A dictionary containing the sensed data. Only Neigbor sensor returns a list of node ids. List[int]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided node_id is invalid.</p> <code>RuntimeError</code> <p>If the sensing operation fails due to system constraints.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef sense(self, node_id: int) -&gt; None:\n    \"\"\"\n    Perform sensing operations for a given node.\n\n    This method collects data related to the specified node and returns the sensed information.\n\n    Args:\n        node_id (int): The unique identifier of the node to sense.\n\n    Sensed Data type:\n        Dict[str, Any]: A dictionary containing the sensed data.\n        Only Neigbor sensor returns a list of node ids. List[int]\n\n    Raises:\n        ValueError: If the provided node_id is invalid.\n        RuntimeError: If the sensing operation fails due to system constraints.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensor.set_owner","title":"<code>set_owner(owner)</code>  <code>abstractmethod</code>","text":"<p>Set the owner of the sensor. Owner is a string that identifies the entity responsible for the sensor. Used for setting the owning agent.</p> <p>This method assigns a specific owner to the sensor, which can be used for identification or management purposes.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str or None</code> <p>The name of the owner to assign to the sensor.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided owner is not a string.</p> <code>ValueError</code> <p>If the provided owner is invalid or empty.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef set_owner(self, owner: Union[str, None]) -&gt; None:\n    \"\"\"\n    Set the owner of the sensor. Owner is a string that identifies the entity responsible for the sensor.\n    Used for setting the owning agent.\n\n    This method assigns a specific owner to the sensor, which can be used for identification\n    or management purposes.\n\n    Args:\n        owner (str or None): The name of the owner to assign to the sensor.\n\n    Raises:\n        TypeError: If the provided owner is not a string.\n        ValueError: If the provided owner is invalid or empty.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensor.update","title":"<code>update(data)</code>  <code>abstractmethod</code>","text":"<p>Update the sensor's data.</p> <p>This method modifies the sensor's internal data based on the provided information.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the data to update the sensor with.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the provided data contains invalid keys.</p> <code>ValueError</code> <p>If the provided data is malformed or incomplete.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef update(self, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update the sensor's data.\n\n    This method modifies the sensor's internal data based on the provided information.\n\n    Args:\n        data (Dict[str, Any]): A dictionary containing the data to update the sensor with.\n\n    Raises:\n        KeyError: If the provided data contains invalid keys.\n        ValueError: If the provided data is malformed or incomplete.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensorEngine","title":"<code>ISensorEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a sensor engine.</p> <p>The sensor engine manages the lifecycle of sensors, including their creation, retrieval, and termination. It serves as a central point for interacting with various sensors within the system.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>class ISensorEngine(ABC):\n    \"\"\"\n    Abstract base class representing a sensor engine.\n\n    The sensor engine manages the lifecycle of sensors, including their creation, retrieval,\n    and termination. It serves as a central point for interacting with various sensors\n    within the system.\n    \"\"\"\n\n    @abstractmethod\n    def create_sensor(self, sensor_id: str, sensor_type: SensorType, **kwargs: Dict[str, Any]) -&gt; ISensor:\n        \"\"\"\n        Create a new sensor of the specified type.\n\n        This method initializes a sensor based on the provided type and data, and registers\n        it within the sensor engine for management.\n\n        Args:\n            sensor_id (str): The unique identifier for the sensor to be created.\n            sensor_type (SensorType): The type of sensor to create.\n\n        Kwargs:\n            **kwargs: Additional keyword arguments for sensor initialization.\n\n        Returns:\n            ISensor: The newly created sensor instance.\n\n        Raises:\n            ValueError: If the sensor_type is unsupported or sensor_data is invalid.\n            RuntimeError: If the sensor cannot be created due to system constraints.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_sensor(self, sensor_id: Any) -&gt; ISensor:\n        \"\"\"\n        Retrieve a sensor by its unique identifier.\n\n        This method fetches the sensor instance corresponding to the provided sensor_id.\n\n        Args:\n            sensor_id (Any): The unique identifier of the sensor to retrieve.\n\n        Returns:\n            ISensor: The sensor instance associated with the provided sensor_id.\n\n        Raises:\n            KeyError: If no sensor with the specified sensor_id exists.\n            TypeError: If the sensor_id is of an incorrect type.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_sensor(self, sensor: ISensor) -&gt; None:\n        \"\"\"\n        Add a sensor to the sensor engine.\n\n        This method registers an existing sensor instance within the sensor engine for management.\n\n        Args:\n            sensor (ISensor): The sensor instance to add.\n\n        Raises:\n            TypeError: If the provided sensor is not an instance of ISensor.\n            ValueError: If the sensor is already registered.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def terminate(self) -&gt; None:\n        \"\"\"\n        Terminate the sensor engine and perform necessary cleanup operations.\n\n        This method gracefully shuts down the sensor engine, ensuring that all sensors\n        are properly terminated and that resources are released.\n\n        Raises:\n            RuntimeError: If the sensor engine fails to terminate gracefully.\n            IOError: If there are issues during the cleanup process.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def custom(self, name: str) -&gt; Callable[[ISensor], ISensor]:\n        \"\"\"\n        Decorator for custom sensor\n        For example, if the user create a new custom sensor, add a new type to SensorType enum\n        and implement the new sensor class, the user can add the custom sensor to the sensor engine\n        using this method.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensorEngine.add_sensor","title":"<code>add_sensor(sensor)</code>  <code>abstractmethod</code>","text":"<p>Add a sensor to the sensor engine.</p> <p>This method registers an existing sensor instance within the sensor engine for management.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>ISensor</code> <p>The sensor instance to add.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided sensor is not an instance of ISensor.</p> <code>ValueError</code> <p>If the sensor is already registered.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef add_sensor(self, sensor: ISensor) -&gt; None:\n    \"\"\"\n    Add a sensor to the sensor engine.\n\n    This method registers an existing sensor instance within the sensor engine for management.\n\n    Args:\n        sensor (ISensor): The sensor instance to add.\n\n    Raises:\n        TypeError: If the provided sensor is not an instance of ISensor.\n        ValueError: If the sensor is already registered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensorEngine.create_sensor","title":"<code>create_sensor(sensor_id, sensor_type, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Create a new sensor of the specified type.</p> <p>This method initializes a sensor based on the provided type and data, and registers it within the sensor engine for management.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_id</code> <code>str</code> <p>The unique identifier for the sensor to be created.</p> required <code>sensor_type</code> <code>SensorType</code> <p>The type of sensor to create.</p> required Kwargs <p>**kwargs: Additional keyword arguments for sensor initialization.</p> <p>Returns:</p> Name Type Description <code>ISensor</code> <code>ISensor</code> <p>The newly created sensor instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sensor_type is unsupported or sensor_data is invalid.</p> <code>RuntimeError</code> <p>If the sensor cannot be created due to system constraints.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef create_sensor(self, sensor_id: str, sensor_type: SensorType, **kwargs: Dict[str, Any]) -&gt; ISensor:\n    \"\"\"\n    Create a new sensor of the specified type.\n\n    This method initializes a sensor based on the provided type and data, and registers\n    it within the sensor engine for management.\n\n    Args:\n        sensor_id (str): The unique identifier for the sensor to be created.\n        sensor_type (SensorType): The type of sensor to create.\n\n    Kwargs:\n        **kwargs: Additional keyword arguments for sensor initialization.\n\n    Returns:\n        ISensor: The newly created sensor instance.\n\n    Raises:\n        ValueError: If the sensor_type is unsupported or sensor_data is invalid.\n        RuntimeError: If the sensor cannot be created due to system constraints.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensorEngine.custom","title":"<code>custom(name)</code>  <code>abstractmethod</code>","text":"<p>Decorator for custom sensor For example, if the user create a new custom sensor, add a new type to SensorType enum and implement the new sensor class, the user can add the custom sensor to the sensor engine using this method.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef custom(self, name: str) -&gt; Callable[[ISensor], ISensor]:\n    \"\"\"\n    Decorator for custom sensor\n    For example, if the user create a new custom sensor, add a new type to SensorType enum\n    and implement the new sensor class, the user can add the custom sensor to the sensor engine\n    using this method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensorEngine.get_sensor","title":"<code>get_sensor(sensor_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve a sensor by its unique identifier.</p> <p>This method fetches the sensor instance corresponding to the provided sensor_id.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_id</code> <code>Any</code> <p>The unique identifier of the sensor to retrieve.</p> required <p>Returns:</p> Name Type Description <code>ISensor</code> <code>ISensor</code> <p>The sensor instance associated with the provided sensor_id.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no sensor with the specified sensor_id exists.</p> <code>TypeError</code> <p>If the sensor_id is of an incorrect type.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef get_sensor(self, sensor_id: Any) -&gt; ISensor:\n    \"\"\"\n    Retrieve a sensor by its unique identifier.\n\n    This method fetches the sensor instance corresponding to the provided sensor_id.\n\n    Args:\n        sensor_id (Any): The unique identifier of the sensor to retrieve.\n\n    Returns:\n        ISensor: The sensor instance associated with the provided sensor_id.\n\n    Raises:\n        KeyError: If no sensor with the specified sensor_id exists.\n        TypeError: If the sensor_id is of an incorrect type.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.ISensorEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the sensor engine and perform necessary cleanup operations.</p> <p>This method gracefully shuts down the sensor engine, ensuring that all sensors are properly terminated and that resources are released.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the sensor engine fails to terminate gracefully.</p> <code>IOError</code> <p>If there are issues during the cleanup process.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>@abstractmethod\ndef terminate(self) -&gt; None:\n    \"\"\"\n    Terminate the sensor engine and perform necessary cleanup operations.\n\n    This method gracefully shuts down the sensor engine, ensuring that all sensors\n    are properly terminated and that resources are released.\n\n    Raises:\n        RuntimeError: If the sensor engine fails to terminate gracefully.\n        IOError: If there are issues during the cleanup process.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"sensor/#gamms.typing.sensor_engine.SensorType","title":"<code>SensorType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of different sensor types.</p> <p>Attributes:</p> Name Type Description <code>CUSTOM</code> <code>Enum</code> <p>Dummy Sensor type when the user create a custom sensor. Data Representation depends on the custom sensor implementation.</p> <code>NEIGHBOR</code> <code>Enum</code> <p>Sensor type for detecting neighboring entities. Data Representation (<code>List[int]</code>): List of node identifiers representing neighbors.</p> <code>MAP</code> <code>Enum</code> <p>Sensor type for map-related data. Data Representation (<code>Dict[str, Dict[int, Union[Node, OSMEdge]]</code>): Keys nodes and edges give respective node and edge data.</p> <code>AGENT</code> <code>Enum</code> <p>Sensor type for agent locations. Data Representation (<code>Dict[str, int]</code>): Dictionary mapping agent names to node identifiers.</p> <code>RANGE</code> <code>Enum</code> <p>Sensor type for range-based data. Data Representation (<code>Dict[str, Dict[int, Union[Node, OSMEdge]]</code>): Keys nodes and edges give respective node and edge data. Range only version of MAP.</p> <code>ARC</code> <code>Enum</code> <p>Sensor type for arc-based data. Data Representation (<code>Dict[str, Dict[int, Union[Node, OSMEdge]]</code>): Keys nodes and edges give respective node and edge data. Range and Fov version of MAP.</p> <code>AGENT_RANGE</code> <code>Enum</code> <p>Sensor type for agent range data. Data Representation (<code>Dict[str, int]</code>): Dictionary mapping agent names to node identifiers. Range only version of AGENT.</p> <code>AGENT_ARC</code> <code>Enum</code> <p>Sensor type for agent arc data. Data Representation (<code>Dict[str, int]</code>): Dictionary mapping agent names to node identifiers. Range and Fov version of AGENT.</p> <code>AERIAL</code> <code>Enum</code> <p>Sensor type for aerial map data. Data Representation (<code>Dict[str, Union[Dict[int, Node], List[OSMEdge]]]</code>): Keys nodes and edges give respective node and edge data. Range and Fov version of MAP for aerial agents.</p> <code>AERIAL_AGENT</code> <code>Enum</code> <p>Sensor type for aerial agent data. Data Representation (<code>Dict[str, Tuple[AgentType, Tuple[float, float, float]]]</code>): Dictionary mapping agent names to (x, y, z) coordinates.</p> Source code in <code>gamms/typing/sensor_engine.py</code> <pre><code>class SensorType(Enum):\n    \"\"\"\n    Enumeration of different sensor types.\n\n    Attributes:\n        CUSTOM (Enum): Dummy Sensor type when the user create a custom sensor.\n            Data Representation depends on the custom sensor implementation.\n        NEIGHBOR (Enum): Sensor type for detecting neighboring entities.\n            Data Representation (`List[int]`): List of node identifiers representing neighbors.\n        MAP (Enum): Sensor type for map-related data.\n            Data Representation (`Dict[str, Dict[int, Union[Node, OSMEdge]]`): Keys nodes and edges give respective node and edge data.\n        AGENT (Enum): Sensor type for agent locations.\n            Data Representation (`Dict[str, int]`): Dictionary mapping agent names to node identifiers.\n        RANGE (Enum): Sensor type for range-based data.\n            Data Representation (`Dict[str, Dict[int, Union[Node, OSMEdge]]`): Keys nodes and edges give respective node and edge data. Range only version of MAP.\n        ARC (Enum): Sensor type for arc-based data.\n            Data Representation (`Dict[str, Dict[int, Union[Node, OSMEdge]]`): Keys nodes and edges give respective node and edge data. Range and Fov version of MAP.\n        AGENT_RANGE (Enum): Sensor type for agent range data.\n            Data Representation (`Dict[str, int]`): Dictionary mapping agent names to node identifiers. Range only version of AGENT.\n        AGENT_ARC (Enum): Sensor type for agent arc data.\n            Data Representation (`Dict[str, int]`): Dictionary mapping agent names to node identifiers. Range and Fov version of AGENT.\n        AERIAL (Enum): Sensor type for aerial map data.\n            Data Representation (`Dict[str, Union[Dict[int, Node], List[OSMEdge]]]`): Keys nodes and edges give respective node and edge data. Range and Fov version of MAP for aerial agents.\n        AERIAL_AGENT (Enum): Sensor type for aerial agent data.\n            Data Representation (`Dict[str, Tuple[AgentType, Tuple[float, float, float]]]`): Dictionary mapping agent names to (x, y, z) coordinates.\n\n    \"\"\"\n    CUSTOM = 0\n    NEIGHBOR = 1\n    MAP = 2\n    AGENT = 3\n    RANGE = 4\n    ARC = 5\n    AGENT_RANGE = 6\n    AGENT_ARC = 7\n    AERIAL = 8\n    AERIAL_AGENT = 9\n</code></pre>"},{"location":"start/","title":"Getting Started","text":"<p>Gamms is a library designed to simulate adversial games in a graph based world. This guide will help you quickly install and set up Gamms so you can start experimenting as soon as possible.</p>"},{"location":"start/#python-requierement","title":"Python Requierement","text":"<p>Gamms requires Python 3.9 or later. If you already have a suitable version installed, skip to Installation and Setup.</p> <p>Otherwise, visit the official Python download page to install a compatible version for your device (Windows, Mac, or Linux): Python</p>"},{"location":"start/#installation-and-setup","title":"Installation and Setup","text":"<p>Before installing Gamms, ensure that pip is installed. Most Python distributions include pip by default; if you need to install it separately, follow the instructions on the pip documentation page.</p> <p>Now, you can install Gamms using pip.</p> <pre><code>pip install gamms\n</code></pre> <p>If you want to setup using source code, use the appropriate commands below for your operating system to install <code>git</code> and <code>wget</code> if you don't have them already.</p>"},{"location":"start/#installing-git","title":"Installing Git","text":"MacLinuxWindows <ul> <li>Git via Homebrew</li> <li>Wget via Homebrew</li> </ul> <ul> <li><code>sudo apt-get install git wget</code> (Debian/Ubuntu)</li> <li><code>sudo dnf install git wget</code> (Fedora)</li> <li><code>sudo pacman -S git wget</code> (Arch)</li> </ul> <ul> <li>Git for Windows</li> <li>Wget for Windows</li> </ul>"},{"location":"start/#local-setup","title":"Local Setup","text":"<p>Create a new folder in the directory where you want your project to live. We'll name it <code>gamms</code>: <pre><code>mkdir gamms\ncd gamms\n</code></pre> Create a Python virtual environment within this folder. You can do this using <code>python</code> or <code>python3</code>, depending on your system: <pre><code>python -m venv venv\n</code></pre></p> <p>This command will create a subfolder named <code>venv</code> that contains your virtual environment files.</p> <p>Activate the virtual environment:</p> Mac/LinuxWindows <pre><code>source venv/bin/activate\n</code></pre> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>Install Gamms within the virtual environment: <pre><code>python -m pip install git+https://github.com/GAMMSim/gamms.git@dev\n</code></pre></p> <p>Verify your installation: <pre><code>   import gamms\n   print(\"Gamms version:\", gamms.__version__)\n</code></pre></p> <p>Once these steps are completed, you will have Gamms installed in a clean virtual environment. Remember to activate the virtual environment (step 3) whenever you want to work on your project.</p>"},{"location":"strategy/","title":"Developing Agent Strategies","text":"<p>The simulator treats strategies as a function that maps the state of the agent to an action. The state contains information about the agent's location as well as the data collected from the sensors. The action is the movement of the agent in the environment.</p>"},{"location":"strategy/#understanding-the-agent-state","title":"Understanding the Agent State","text":"<p>The agent state is a dictionary that has the following base structure:</p> <p><pre><code>state = {\n    'curr_pos': (integer) # The location id of the node where the agent is currently located\n    'sensor' : {\n        'sensor1': (Sensor 1 Type, Sensor 1 Data), # The data collected by sensor 1\n        'sensor2': (Sensor 2 Type, Sensor 2 Data), # The data collected by sensor 2\n        ...\n    }\n}\n</code></pre> The exact structure depends on what type of sensors are associated with the agent. This will become clearer as we dive into the examples later.</p> <p>The user needs to tell where the agent will move. To do that, the user only needs to add an additional key called <code>'action'</code> to the state dictionary. Note that it should be the inputed state dictionary that is modified and returned. In essence, the strategy function should look like this:</p> <pre><code>def strategy(state):\n    # Do something with the state\n    state['action'] = (integer) # The location id of the node where the agent will move\n    return\n</code></pre> <p>It is also possible that this strategy function is inside an agent class. This is useful when the agent has some internal state that needs to be maintained. There are no restrictions on how the class should be defined. The only requirement is that the class should have a method that takes state as input and updates the state with the action.</p> <pre><code>class Agent:\n    def __init__(self, arguements):\n        # Initialize the agent\n        pass\n\n    def strategy(self, state):\n        # Do something with the state\n        state['action'] = (integer) # The location id of the node where the agent will move\n        return\n</code></pre>"},{"location":"strategy/#defining-the-mapping-function","title":"Defining the Mapping Function","text":"<p>The game will try to import the <code>map_strategy</code> function from the strategy file. For the strategies to work, the user needs to define this function. The function is given an <code>agent_config</code> dictionary that contains the configuration of the agents in the game. The user needs to return a dictionary that maps the keys of the <code>agent_config</code> to the respective strategy functions. A typical <code>agent_config</code> dictionary looks like the following:</p> <pre><code>agent_config = {\n    'agent_0': {\n        'meta': {'team': 0},\n        'sensors': ['neigh_0', 'map', 'agent'],\n        'start_node_id': 0\n    },\n    'agent_1': {\n        'meta': {'team': 0},\n        'sensors': ['neigh_1', 'map', 'agent'],\n        'start_node_id': 1\n    },\n    ...\n}\n</code></pre> <p>Here, the keys are the agent names and the values are dictionaries that contain the agent's configuration. The <code>meta</code> key contains the metadata of the agent. The <code>sensors</code> key contains the list of sensors that the agent has. The <code>start_node_id</code> key contains the location id of the node where the agent will start.</p> <p>A typical <code>map_strategy</code> function will look like the following:</p> <pre><code>def strategy(state):\n    # Do something with the state\n    state['action'] = (integer) # The location id of the node where the agent will move\n    return\n\ndef map_strategy(agent_config):\n    strategy_map = {}\n    for agent_name in agent_config:\n        strategy_map[agent_name] = strategy\n    return strategy_map\n</code></pre> <p>In case the user wants to use the agent class, the <code>map_strategy</code> function will look like the following:</p> <pre><code>def map_strategy(agent_config):\n    strategy_map = {}\n    for agent_name in agent_config:\n        strategy_map[agent_name] = Agent(arguements).strategy\n    return strategy_map\n</code></pre>"},{"location":"strategy/#random-walk-example","title":"Random Walk Example","text":"<p>Suppose we have an example game where we want the agents to move randomly. Let's take a quick look at how the game defines the agents and the sensors.</p> <pre><code>sensor_config = {\n    'neigh_0': {\n        'type': gamms.sensor.SensorType.NEIGHBOR,\n    },\n    'neigh_1': {\n        'type': gamms.sensor.SensorType.NEIGHBOR,\n    },\n}\n\nagent_config = {\n    'agent_0': {\n        'meta': {'team': 0},\n        'sensors': ['neigh_0'],\n        'start_node_id': 0\n    },\n    'agent_1': {\n        'meta': {'team': 0},\n        'sensors': ['neigh_1'],\n        'start_node_id': 1\n    }\n}\n</code></pre> <p>You can observe that each agent has a neighbor sensor. What that means is that the agent can see the neighbors of the node where it is currently located. The user can define the strategy function as follows:</p> <pre><code>import random\nfrom gamms import sensor\n\ndef strategy(state):\n    sensor_data = state['sensor']\n    for (type, data) in sensor_data.values():\n        if type == sensor.SensorType.NEIGHBOR:\n            choice = random.choice(range(len(data)))\n            state['action'] = data[choice]\n            break\n\n\ndef map_strategy(agent_config):\n    strategies = {}\n    for name in agent_config.keys():\n        strategies[name] = strategy\n    return strategies\n</code></pre> <p>In this example, the strategy function randomly chooses a neighbor of the current node and moves to that node. The <code>map_strategy</code> function maps the agent names to the strategy functions. The game will use this mapping to run the game.</p>"},{"location":"strategy/#a-coverage-example","title":"A Coverage Example","text":"<p>Suppose we have the exact same game as before but we want the agents to cover the entire graph. The agents do not get information about the entire graph but they can see the neighbors of the node where they are currently located. As such, now we need to remember the nodes that the agents have visited as well as construct the graph from the neighbors. A class based approach is more suitable for this example.</p> <pre><code>from gamms import sensor\nimport random\n\n# Shared graph class for all agents\n# This is a simple graph class that is used to construct the graph from the neighbors\n# It also keeps track of the nodes that have been visited\n# The graph is constructed from the neighbors of the nodes\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n        self.visited = set()\n\n    def add_node(self, node_id, neighbors):\n        self.graph[node_id] = neighbors\n\n    def visit(self, node_id):\n        self.visited.add(node_id)\n\n    def get_neighbors(self, node_id):\n        return self.graph[node_id]\n\n    def get_visited(self):\n        return self.visited\n\n# Agent class that uses the graph class\n# The agent keeps track of the graph and the visited nodes\n# The agent moves to the neighbor that has not been visited\n# If all neighbors have been visited, the agent moves to a random neighbor\nclass Agent:\n    def __init__(self, graph):\n        self.graph = graph\n\n    def strategy(self, state):\n        sensor_data = state['sensor']\n        for (type, data) in sensor_data.values():\n            if type == sensor.SensorType.NEIGHBOR:\n                # Construct the graph\n                neighbors = data\n                curr_pos = state['curr_pos']\n                self.graph.add_node(curr_pos, neighbors)\n                visited = self.graph.get_visited()\n                unvisited = [node for node in neighbors if node not in visited]\n                if len(unvisited) &gt; 0:\n                    state['action'] = random.choice(unvisited)\n                else:\n                    state['action'] = random.choice(neighbors)\n                break\n\n# The map_strategy function\n# The function creates the graph and the agents\n# The agents are then mapped to the strategy functions\ndef map_strategy(agent_config):\n    graph = Graph()\n    strategies = {}\n    for agent_name in agent_config:\n        strategies[agent_name] = Agent(graph).strategy\n    return strategies\n</code></pre> <p>We see that the agents use a common graph object to communicate with each other. This is a simple example of how the agents can share information with each other. However, it should be noted that newer versions of the simulator will provide a more robust way of sharing information between agents via communication sensors. Right now, the implemented policy is a centralized policy where the agents share information with each other via a common object.</p>"},{"location":"visual/","title":"Visualization","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a visualization engine.</p> <p>The visualization engine is responsible for rendering the graph and agents, handling simulation updates, processing human inputs, and managing the overall visualization lifecycle.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.add_artist","title":"<code>add_artist(name, artist)</code>  <code>abstractmethod</code>","text":"<p>Add a custom artist or object to the visualization.</p> <p>This method adds a custom artist or object to the visualization, allowing for additional elements to be displayed alongside the graph and agents. The artist can be used to render custom shapes, text, images, or other visual components within the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier for the custom artist.</p> required <code>artist</code> <code>IArtist</code> <p>The artist object representing the custom visualization element.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.human_input","title":"<code>human_input(agent_name, state)</code>  <code>abstractmethod</code>","text":"<p>Process input from a human player or user.</p> <p>This method handles input data provided by a human user, allowing for interactive control or modification of the visualization. It can be used to receive commands, adjust settings, or influence the simulation based on user actions.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>The unique name of the agent.</p> required <code>state</code> <code>Dict[str, Any]</code> <p>A dictionary containing the current state of the system or the input data from the user. Expected keys may include: - <code>command</code> (str): The command issued by the user. - <code>parameters</code> (Dict[str, Any]): Additional parameters related to the command. - Other state-related information as needed.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, Tuple[float, float, float]]</code> <p>The target node id selected by the user.</p> <code>Union[int, Tuple[float, float, float]]</code> <p>Tuple[float, float, float]: The target position (x, y, z) selected by the user for aerial agents.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input <code>state</code> contains invalid or unsupported commands.</p> <code>KeyError</code> <p>If required keys are missing from the <code>state</code> dictionary.</p> <code>TypeError</code> <p>If the types of the provided input data do not match expected types.</p> <code>RuntimeError</code> <p>If the agent type is unknown or unsupported.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.remove_artist","title":"<code>remove_artist(name)</code>  <code>abstractmethod</code>","text":"<p>Remove a custom artist or object from the visualization.</p> <p>This method removes a custom artist or object from the visualization, effectively hiding or deleting the element from the display.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the custom artist to remove.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_circle","title":"<code>render_circle(x, y, radius, color, width, perform_culling_test)</code>  <code>abstractmethod</code>","text":"<p>Render a circle shape at the specified position with the given radius and color.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the circle's center.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the circle's center.</p> required <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>color</code> <code>Tuple[Union[int, float], Union[int, float], Union[int, float]]</code> <p>The color of the circle in RGB format.</p> required <code>width</code> <code>int</code> <p>The width of the circle's outline in pixels. If equal to 0, the circle is filled.</p> required <code>perform_culling_test</code> <code>bool</code> <p>Whether to perform culling.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_layer","title":"<code>render_layer(layer_id)</code>  <code>abstractmethod</code>","text":"<p>Render the specified layer of the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>The layer number to render.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_line","title":"<code>render_line(start_x, start_y, end_x, end_y, color, width, is_aa, perform_culling_test)</code>  <code>abstractmethod</code>","text":"<p>Render a line segment between two points with the specified color and width.</p> <p>Parameters:</p> Name Type Description Default <code>start_x</code> <code>float</code> <p>The x-coordinate of the starting point.</p> required <code>start_y</code> <code>float</code> <p>The y-coordinate of the starting point.</p> required <code>end_x</code> <code>float</code> <p>The x-coordinate of the ending point.</p> required <code>end_y</code> <code>float</code> <p>The y-coordinate of the ending point.</p> required <code>color</code> <code>Tuple[Union[int, float], Union[int, float], Union[int, float]]</code> <p>The color of the line in RGB format.</p> required <code>width</code> <code>int</code> <p>The width of the line in pixels. Only non-antialiasing lines supports width.</p> required <code>is_aa</code> <code>bool</code> <p>Whether to use antialiasing for smoother rendering.</p> required <code>perform_culling_test</code> <code>bool</code> <p>Whether to perform culling.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_linestring","title":"<code>render_linestring(points, color, width, closed, is_aa, perform_culling_test)</code>  <code>abstractmethod</code>","text":"<p>Render a series of connected line segments between multiple points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Tuple[float, float]]</code> <p>A list of (x, y) coordinate tuples defining the line segments.</p> required <code>color</code> <code>Tuple[Union[int, float], Union[int, float], Union[int, float]]</code> <p>The color of the lines in RGB format.</p> required <code>width</code> <code>int</code> <p>The width of the lines in pixels. Only non-antialiasing lines supports width.</p> required <code>closed</code> <code>bool</code> <p>Whether the line segments form a closed shape.</p> required <code>is_aa</code> <code>bool</code> <p>Whether to use antialiasing for smoother rendering.</p> required <code>perform_culling_test</code> <code>bool</code> <p>Whether to perform culling.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_polygon","title":"<code>render_polygon(points, color, width, perform_culling_test)</code>  <code>abstractmethod</code>","text":"<p>Render a polygon shape or outline defined by a list of vertices with the specified color and width.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Tuple[float, float]]</code> <p>A list of (x, y) coordinate tuples defining the polygon vertices.</p> required <code>color</code> <code>Tuple[Union[int, float], Union[int, float], Union[int, float]]</code> <p>The color of the polygon in RGB format.</p> required <code>width</code> <code>int</code> <p>The width of the polygon outline in pixels. If equal to 0, the polygon is filled.</p> required <code>perform_culling_test</code> <code>bool</code> <p>Whether to perform culling.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_rectangle","title":"<code>render_rectangle(x, y, width, height, color, perform_culling_test)</code>  <code>abstractmethod</code>","text":"<p>Render a rectangle shape at the specified position with the given dimensions and color.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the rectangle's center.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the rectangle's center.</p> required <code>width</code> <code>float</code> <p>The width of the rectangle.</p> required <code>height</code> <code>float</code> <p>The height of the rectangle.</p> required <code>color</code> <code>Tuple[Union[int, float], Union[int, float], Union[int, float]]</code> <p>The color of the rectangle in RGB format.</p> required <code>perform_culling_test</code> <code>bool</code> <p>Whether to perform culling.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.render_text","title":"<code>render_text(text, x, y, color, perform_culling_test)</code>  <code>abstractmethod</code>","text":"<p>Render text at the specified position with the given content and color.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text content to display.</p> required <code>x</code> <code>float</code> <p>The x-coordinate of the text's center position.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the text's center position.</p> required <code>color</code> <code>Tuple[Union[int, float], Union[int, float], Union[int, float]]</code> <p>The color of the text in RGB format.</p> required <code>perform_culling_test</code> <code>bool</code> <p>Whether to perform culling.</p> required"},{"location":"visual/#gamms.typing.IVisualizationEngine.set_agent_visual","title":"<code>set_agent_visual(name, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Configure the visual representation of a specific agent.</p> <p>This method sets up visual parameters for an individual agent, allowing customization of how the agent is displayed within the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the agent to configure.</p> required <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Arbitrary keyword arguments representing visual settings. Possible keys include: - <code>color</code> (str): The color to represent the agent. - <code>shape</code> (str): The shape to use for the agent's representation. - <code>size</code> (float): The size of the agent in the visualization.</p> <code>{}</code>"},{"location":"visual/#gamms.typing.IVisualizationEngine.set_graph_visual","title":"<code>set_graph_visual(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Configure the visual representation of the graph.</p> <p>This method sets up visual parameters such as colors, sizes, layouts, and other graphical attributes for the entire graph. It allows customization of how the graph is displayed to the user.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Arbitrary keyword arguments representing visual settings. Possible keys include: - <code>color_scheme</code> (str): The color scheme to use for nodes and edges. - <code>layout</code> (str): The layout algorithm for positioning nodes. - <code>node_size</code> (float): The size of the graph nodes. - <code>edge_width</code> (float): The width of the graph edges. - Additional visual parameters as needed.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the provided visual settings are invalid.</p> <code>TypeError</code> <p>If the types of the provided settings do not match expected types.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.set_sensor_visual","title":"<code>set_sensor_visual(name, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Configure the visual representation of a specific sensor.</p> <p>This method sets up visual parameters for an individual sensor, allowing customization of how the sensor is displayed within the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name identifier of the sensor to configure.</p> required <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Arbitrary keyword arguments representing visual settings. Possible keys include: - <code>color</code> (str): The color to represent the sensor. - <code>shape</code> (str): The shape to use for the sensor's representation. - <code>size</code> (float): The size of the sensor in the visualization.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the sensor with the specified name does not exist.</p> <code>ValueError</code> <p>If the sensor type is not supported for default visualization.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.simulate","title":"<code>simulate()</code>  <code>abstractmethod</code>","text":"<p>Execute a simulation step to update the visualization.</p> <p>This method advances the simulation by one step, updating the positions, states, and visual representations of the graph and agents. It should be called repeatedly within a loop to animate the visualization in real-time.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the simulation cannot be advanced due to internal errors.</p> <code>ValueError</code> <p>If the simulation parameters are invalid or inconsistent.</p>"},{"location":"visual/#gamms.typing.IVisualizationEngine.terminate","title":"<code>terminate()</code>  <code>abstractmethod</code>","text":"<p>Terminate the visualization engine and clean up resources.</p> <p>This method is called when the simulation or application is exiting. It should handle the graceful shutdown of the visualization engine, ensuring that all resources are properly released and that the display is correctly closed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the engine fails to terminate gracefully.</p> <code>IOError</code> <p>If there are issues during the cleanup process.</p>"},{"location":"tutorials/","title":"User Tutorials","text":"<p>This section contains a series of tutorials that will guide you through the process of using GAMMS. Each tutorial will build on the previous one, introducing new features and concepts as we go along. The tutorials are designed to be easy to follow and will provide you with a solid understanding of how to use GAMMS for your own projects.</p> <ul> <li>Writing your First Simulation</li> <li>Converting to Realistic Scenarios</li> <li>Final Touches &amp; Analysis Tools</li> </ul>"},{"location":"tutorials/first_simulation/","title":"Writing your First Simulation","text":"<p>Our goal in this tutorial is to start developing a simple grid world simulation with GAMMS. We will extend this example in coming tutorials to introduce the various features of GAMMS as well as flesh out a complex scenario at the end of all the tutorials. The goal of this tutorial is to get you familiar with the basic concepts of GAMMS and how to use it to create a simple simulation.</p> <p>First, we need to create a project directory. This is where we will store all our simulation files. The  project directory can be anywhere on your computer but for keeping things together we will create a directory called <code>gammstutorial</code> in the virtual environment we created in the installation tutorial.</p> <p>We will be completely working in this directory so make sure you are in the right place. Ensure you have activated the virtual environment before running any files that we create and always be in the <code>gammstutorial</code> directory when running the files. You can check if you are in the right directory by running the following command:</p> <pre><code>pwd\n</code></pre>"},{"location":"tutorials/first_simulation/#visualizing-a-grid","title":"Visualizing a Grid","text":"<p>Create a file called <code>game.py</code> in the <code>gammstutorial</code> directory. This file is the entry point for our simulation. Copy the following code into the file:</p> game.py<pre><code>import time\nimport gamms\n\n# create a context with PYGAME as the visual engine\nctx = gamms.create_context(vis_engine=gamms.visual.Engine.PYGAME)\n\ngraph = ctx.graph.graph # get the graph object from the context\n\n# Create a 1x1 grid\n\ngraph.add_node({'id': 0, 'x': 0, 'y': 0}) # add a node to the graph with id 0 and coordinates (0, 0)\ngraph.add_node({'id': 1, 'x': 100.0, 'y': 0}) # add a node to the graph with id 1 and coordinates (100, 0)\ngraph.add_node({'id': 2, 'x': 100.0, 'y': 100.0}) # add a node to the graph with id 2 and coordinates (100, 100)\ngraph.add_node({'id': 3, 'x': 0, 'y': 100.0}) # add a node to the graph with id 3 and coordinates (0, 100)\ngraph.add_edge({'id': 0, 'source': 0, 'target': 1, 'length': 1.0}) # add an edge to the graph with id 0 from node 0 to node 1\ngraph.add_edge({'id': 1, 'source': 1, 'target': 2, 'length': 1.0}) # add an edge to the graph with id 1 from node 1 to node 2\ngraph.add_edge({'id': 2, 'source': 2, 'target': 3, 'length': 1.0}) # add an edge to the graph with id 2 from node 2 to node 3\ngraph.add_edge({'id': 3, 'source': 3, 'target': 0, 'length': 1.0}) # add an edge to the graph with id 3 from node 3 to node 0\ngraph.add_edge({'id': 4, 'source': 0, 'target': 3, 'length': 1.0}) # add an edge to the graph with id 4 from node 0 to node 3\ngraph.add_edge({'id': 5, 'source': 3, 'target': 2, 'length': 1.0}) # add an edge to the graph with id 5 from node 3 to node 2\ngraph.add_edge({'id': 6, 'source': 2, 'target': 1, 'length': 1.0}) # add an edge to the graph with id 6 from node 2 to node 1\ngraph.add_edge({'id': 7, 'source': 1, 'target': 0, 'length': 1.0}) # add an edge to the graph with id 7 from node 1 to node 0\n\n\n# Create the graph visualization\n\ngraph_artist = ctx.visual.set_graph_visual(width=1980, height=1080) # set the graph visualization with width 1980 and height 1080\n\nt = time.time() # get the current time\nwhile time.time() - t &lt; 120: # run the loop for 120 seconds\n    ctx.visual.simulate() # Draw loop for the visual engine\n\nctx.terminate() # terminate the context\n</code></pre> <p>GAMMS uses a context object to manage the simulation. The context object is created using the <code>create_context</code> function. The line below creates a context object with <code>PYGAME</code> as the visual engine. The other option we have is <code>NO_VIS</code> which is used when we do not want to visualize the simulation.</p> <pre><code># create a context with PYGAME as the visual engine\nctx = gamms.create_context(vis_engine=gamms.visual.Engine.PYGAME)\n</code></pre> <p>The actual graph object is created inside the context object. Without going into the details, there is a graph manager <code>ctx.graph</code> that manages the graph object <code>ctx.graph.graph</code>. The graph object is a directed graph that allows us to add nodes and edges to the graph. We use the <code>add_node</code> and <code>add_edge</code> methods to add nodes and edges to the graph. Each node and edge has an id and some attributes. The id is used to identify the node or edge in the graph. The attributes are used to store information about the node or edge. In this case, we are using the <code>x</code> and <code>y</code> attributes to store the coordinates of the node in the grid. The <code>length</code> attribute is used to store the length of the edge. The length attribute is not directly used in this example andd we will come back to it later. However, it needs to be defined to add the edge to the graph. The <code>source</code> and <code>target</code> attributes are used the ids of the source and target nodes of the edge.</p> <p>Once we have added the nodes and edges to the graph, we need to create the graph visualization.</p> <pre><code>graph_artist = ctx.visual.set_graph_visual(width=1980, height=1080) # set the graph visualization with width 1980 and height 1080\n</code></pre> <p>We do this using the <code>set_graph_visual</code> method of the visual engine. We pass extra parameters to the method to set the width and height of the visualization but these are optional. The default values are 1280 and 720 respectively. The <code>set_graph_visual</code> method returns a graph artist object that is used to draw the graph. We will discuss more about artists in later tutorials. The good part is, we do not need to worry about handling the drawing of the graph or what exactly the artist is doing to get started.</p> <p>The last part of the code is a loop that runs for 120 seconds. The loop calls the <code>simulate</code> method of the visual engine to draw the graph. You will now see a window with the square. You can scroll the mouse to zoom in and out of the graph, and use the <code>WASD</code> keys to move around the graph. The simulation will run for 120 seconds and then exit automatically.</p> <p> A simple 2x2 square grid visualization shown in the GAMMS window</p> <p>Before moving to the next part, let's make a bigger grid and make it an <code>n x n</code> grid. We will create a function that will create a grid of size <code>n x n</code> and add it to the graph. The function will take the size of the grid as an argument and create the nodes and edges for the grid. The function will be called <code>create_grid</code> and will look like this:</p> <pre><code>def create_grid(graph, n):\n    edge_count = 0 # initialize the edge count to 0\n    for i in range(n):\n        for j in range(n):\n            # add a node to the graph with id i * n + j and coordinates (i, j)\n            graph.add_node({'id': i * n + j, 'x': i * 100.0, 'y': j * 100.0})\n            if i &gt; 0:\n                # add an edge to the graph from node (i - 1) * n + j to node i * n + j\n                graph.add_edge({'id': edge_count, 'source': (i - 1) * n + j, 'target': i * n + j, 'length': 1.0})\n                # add an edge to the graph from node i * n + j to node (i - 1) * n + j\n                graph.add_edge({'id': edge_count + 1, 'source': i * n + j, 'target': (i - 1) * n + j, 'length': 1.0})\n                edge_count += 2 # increment the edge count by 2\n            if j &gt; 0:\n                # add an edge to the graph from node i * n + (j - 1) to node i * n + j\n                graph.add_edge({'id': edge_count, 'source': i * n + (j - 1), 'target': i * n + j, 'length': 1.0})\n                # add an edge to the graph from node i * n + j to node i * n + (j - 1)\n                graph.add_edge({'id': edge_count + 1, 'source': i * n + j, 'target': i * n + (j - 1), 'length': 1.0})\n                edge_count += 2 # increment the edge count by 2\n</code></pre> <p>It is usually a good idea to separate out the parameters from the code so that we can easily change them later. We will create a file called <code>config.py</code> in the <code>gammstutorial</code> directory and add the parameters to this file. The <code>config.py</code> file will look like this:</p> config.py<pre><code>import gamms\n\n\nVIS_ENGINE = gamms.visual.Engine.PYGAME # visual engine to use\nGRID_SIZE = 5 # size of the grid\n\nSIM_TIME = 120 # time to run the simulation in seconds\n\ngraph_vis_config = {\n    'width': 1980, # width of the graph visualization\n    'height': 1080, # height of the graph visualization\n}\n</code></pre> <p>We have not only added the grid size, but also some other constants or configurations that we had hardcoded in the <code>game.py</code> file. The final <code>game.py</code> file will look like this:</p> game.py<pre><code>import time\nimport gamms\nimport config\n\nctx = gamms.create_context(vis_engine=config.VIS_ENGINE) # create a context with PYGAME as the visual engine\n\ngraph = ctx.graph.graph # get the graph object from the context\n\ndef create_grid(graph, n):\n    edge_count = 0 # initialize the edge count to 0\n    for i in range(n):\n        for j in range(n):\n            # add a node to the graph with id i * n + j and coordinates (i, j)\n            graph.add_node({'id': i * n + j, 'x': i * 100.0, 'y': j * 100.0})\n            if i &gt; 0:\n                # add an edge to the graph from node (i - 1) * n + j to node i * n + j\n                graph.add_edge({'id': edge_count, 'source': (i - 1) * n + j, 'target': i * n + j, 'length': 1.0})\n                # add an edge to the graph from node i * n + j to node (i - 1) * n + j\n                graph.add_edge({'id': edge_count + 1, 'source': i * n + j, 'target': (i - 1) * n + j, 'length': 1.0})\n                edge_count += 2 # increment the edge count by 2\n            if j &gt; 0:\n                # add an edge to the graph from node i * n + (j - 1) to node i * n + j\n                graph.add_edge({'id': edge_count, 'source': i * n + (j - 1), 'target': i * n + j, 'length': 1.0})\n                # add an edge to the graph from node i * n + j to node i * n + (j - 1)\n                graph.add_edge({'id': edge_count + 1, 'source': i * n + j, 'target': i * n + (j - 1), 'length': 1.0})\n                edge_count += 2 # increment the edge count by 2\n\ncreate_grid(graph, config.GRID_SIZE)\n\n\n# Create the graph visualization\n\ngraph_artist = ctx.visual.set_graph_visual(**config.graph_vis_config) # set the graph visualization with width 1980 and height 1080\n\nt = time.time() # get the current time\nwhile time.time() - t &lt; config.SIM_TIME: # run the loop for 120 seconds\n    ctx.visual.simulate() # Draw loop for the visual engine\n\nctx.terminate() # terminate the context\n</code></pre> <p> A larger n\u00d7n grid visualization with the size defined in config.py</p> <p>Final changes in the files can be found in snippets/visualizing_a_grid</p>"},{"location":"tutorials/first_simulation/#creating-agents","title":"Creating Agents","text":"<p>GAMMS provides a specialized agent class that is used to create agents in the simulation. The agents are limited to the graph and can only move along the edges of the graph. The <code>ctx.agent.create_agent</code> call allows us to define an agent in the simulation. The agent needs to have a unique <code>name</code> along with information about where it is at the start of the simulation.</p> <p>Adding the following code to the <code>game.py</code>file before the while loop, it will create an agent at the start of the simulation:</p> <pre><code># Create an agent\nctx.agent.create_agent(name='agent_0', start_node_id=0)\n</code></pre> <p>The <code>start_node_id</code> parameter is the id of the node where the agent will start. The agent will be created at the node with id 0. For making the agent visible in the simulation, we need to also define a visualization for the agent. The agent visualization is created using the <code>set_agent_visual</code> method of the visual engine.</p> <pre><code># Create the agent visualization\n# set the agent visualization with name 'agent_0', color red and size 10\nctx.visual.set_agent_visual(name='agent_0', color=(255, 0, 0), size=10)\n</code></pre> <p>You will notice that the agent is not doing anything in the simulation and is just sitting at the start node. The agent is not moving because we have not defined any behaviour for the agent. Let's try to first get human input to move the agent around. The visual engine provides a way to get user input while displaying possible actions on the screen. We need to edit the while loop to get user input:</p> <pre><code>step_counter = 0 # initialize the step counter to 0\nwhile not ctx.is_terminated(): # run the loop until the context is terminated\n    step_counter += 1 # increment the step counter by 1\n    for agent in ctx.agent.create_iter():\n        # Get the current state of the agent\n        state = agent.get_state() # get the state of the agent\n        # Get human input to move the agent\n        node = ctx.visual.human_input(agent.name, state)\n        state['action'] = node\n        agent.set_state() # set the state of the agent\n\n\n    ctx.visual.simulate() # Draw loop for the visual engine\n    if step_counter == 20:\n        ctx.terminate() # terminate the context after 20 steps\n</code></pre> <p>If you copy the code and replace the while loop in the <code>game.py</code> file with this code, the simulation will crash. This is because we have not defined any way for the agent to sense the environment. The agent can technically move blindly but to show the possible actions, the agent needs to know what the possible actions are. To do this, we need to add a sensor to the agent. Particularly, human input is tied to the <code>NeighborSensor</code> and it is reuqired to be able to support taking inputs from the user. Before going through how to add a sensor, let's first understand the changes we made to the while loop. After that, we will go through a simple example of how to add a sensor to the agent, and see how it works.</p> <p>We have replaced the time based termination to a counter based termination criteria. This is a simple way to simulate steps in a game. It also allows a flexible amount of time to be spent on each step. The next thing we are doing is getting the state of the agent. The state of the agent is a dictionary that contains information about the agent. The <code>get_state</code> method of the agent returns the state of the agent. We are then using the <code>human_input</code> method of the visual engine to get user input for the agent. The <code>human_input</code> method takes the name of the agent and its state as arguments and returns the node id where the agent should move. We are then updating the state of the agent with the action taken by the user. The <code>set_state</code> method of the agent sets the state of the agent. The important part is that the agent movement is tied to the <code>action</code> key in the state dictionary.</p> <p>Let's now add the <code>NeighborSensor</code> to the agent. The <code>NeighborSensor</code> is a sensor that senses the neighbors of the agent. It is used to get the possible actions for the agent. The <code>NeighborSensor</code> is created using the <code>create_sensor</code> method of the agent. The <code>create_sensor</code> method takes the name of the sensor and its type as arguments. The type of the sensor is <code>gamms.sensor.NeighborSensor</code>. We will add the following code to the <code>game.py</code> file after creating the agent:</p> game.py<pre><code># Create a neighbor sensor\nctx.sensor.create_sensor(sensor_id='neigh_0', sensor_type=gamms.sensor.SensorType.NEIGHBOR)\n\n# Register the sensor to the agent\nctx.agent.get_agent('agent_0').register_sensor(name='neigh_0', sensor=ctx.sensor.get_sensor('neigh_0'))\n</code></pre> <p>There are two parts to this code. The first part creates the sensor and the second part registers the sensor to the agent. The <code>create_sensor</code> method of the context creates a sensor with the given id and type. The <code>register_sensor</code> method of the agent registers the sensor to the agent. When the <code>get_state</code> method of the agent is called, the sensor information is updated and added to the state of the agent. The <code>human_input</code> method of the visual engine uses this information to show the possible actions for the agent. You will see that the agent is highlighted and you can see some numbers on the nearby nodes. The correspoding number can be pressed on the keyboard to move the agent to that node. The agent will move to the node and you can see the agent moving around the grid.</p> <p> Agent with NeighborSensor showing numbered actions for player input</p> <p>The maximum number of neighbors that can be handled by human input method is 10. The restriction is only for the human input method and not the sensor itself. The sensor can handle any number of neighbors. The human input method will only show the first 10 neighbors and the rest will be ignored. The human input method will also not show the neighbors if there are more than 10 neighbors. This is a limitation of the current implementation and will be fixed in future releases.</p> <p>Now that we have a base idea of how to add a single agent, let us try to generalize to two agent teams that we can control. Let us make a Red team and a Blue team, each with 5 agents. The base idea is to do multiple calls to the <code>create_agent</code> method using a loop. To make it clean, let us shift some of the configurations to <code>config.py</code> file.</p> config.py<pre><code>import gamms\n\n\nVIS_ENGINE = gamms.visual.Engine.PYGAME # visual engine to use\nGRID_SIZE = 20 # size of the grid\n\nSIM_STEPS = 120 # NUMBER OF STEPS IN THE SIMULATION\n\nRED_TEAM_AGENTS = 10 # NUMBER OF AGENTS IN THE RED TEAM\nBLUE_TEAM_AGENTS = 10 # NUMBER OF AGENTS IN THE BLUE TEAM\n\ngraph_vis_config = {\n    'width': 1980, # width of the graph visualization\n    'height': 1080, # height of the graph visualization\n}\n\nsensor_config = {}\n\nfor i in range(RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    sensor_config[f'neigh_{i}'] = {\n        'type': gamms.sensor.SensorType.NEIGHBOR, # type of the sensor\n    }\n\nagent_config = {}\n\nfor i in range(RED_TEAM_AGENTS):\n    agent_config[f'agent_{i}'] = {\n        'meta': {'team': 0}, # team of the agent\n        'sensors': [f'neigh_{i}'], # sensors of the agent\n        'start_node_id': i, # starting node id of the agent\n    }\n\nfor i in range(RED_TEAM_AGENTS, RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    agent_config[f'agent_{i}'] = {\n        'meta': {'team': 1}, # team of the agent\n        'sensors': [f'neigh_{i}'], # sensors of the agent\n        'start_node_id': 400-1-i, # starting node id of the agent\n    }\n\nagent_vis_config = {}\n\nfor i in range(RED_TEAM_AGENTS):\n    agent_vis_config[f'agent_{i}'] = {\n        'color': (255, 0, 0), # color of the agent\n        'size': 10, # size of the agent\n    }\n\nfor i in range(RED_TEAM_AGENTS, RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    agent_vis_config[f'agent_{i}'] = {\n        'color': (0, 0, 255), # color of the agent\n        'size': 10, # size of the agent\n    }\n</code></pre> <p>There are many things to note in the above code. First, we have made the grid size larger to accommodate the agents and the simulation time is now in terms of steps. The number of agents in each team is also defined in the config file. The <code>sensor_config</code> dictionary contains the sensor configuration for <code>NeighborSensor</code> for each agent. The <code>agent_config</code> dictionary contains the agent configuration for each agent. The <code>meta</code> key is extra information about the agent that can be used during initialization. The <code>sensors</code> key is a list of sensors that are registered to the agent. This way, we do not need to register the sensors to the agent manually. We are storing the each agent's visualization configuration in the <code>agent_vis_config</code> dictionary. With all these dictionaries, we can now easily define the agents and their sensors in the <code>game.py</code> file like this:</p> <pre><code># Create all the sensors\nfor name, sensor in config.sensor_config.items():\n    ctx.sensor.create_sensor(name, sensor['type'], **sensor)\n\n# Create all the agents\nfor name, agent in config.agent_config.items():\n    ctx.agent.create_agent(name, **agent)\n\n\n# Create all agents visualization\nfor name, vis_config in config.agent_vis_config.items():\n    ctx.visual.set_agent_visual(name, **vis_config)\n</code></pre> <p> Red and blue team agents positioned on the grid according to their configurations</p> <p>We have switched the sequence of sensor definition and agent creation. The sensors are created first so that the when the <code>create_agent</code> method is called, the method tries to automatically register the sensors to the agent. But if the sensors are not created, the agent will not be able to register the sensors. So, we need to create the sensors first and then create the agents. We can always do the registration manually but it is easier to do it directly.</p> <p>Final changes in the files can be found in snippets/creating_agents</p>"},{"location":"tutorials/first_simulation/#creating-scenario-rules","title":"Creating Scenario Rules","text":"<p>Now that we have set up the agents and the environment, we need to define the rules of the scenario. We already have implcitly defined a rule by defining the termination based on turn count. Rules in GAMMS are defined directly in the <code>game</code> file. These rules are simple definitions that can directly mutate the game state. An easy way to define a rule is to create a function that takes the context as an argument and do condition checks. The way these rules actually come into play is by actually calling the function in the main loop, giving full control in which order the rules apply.</p> <p>Let us try to implement the following rules:</p> <ol> <li>The game will run for atleast 120 steps and at most 1000 steps.</li> <li>If two agents of opposite teams are on the same node, they will be reset to their starting positions. Lets call this the tag rule.</li> <li>If a blue agent reaches any red agents' starting position, blue team will get a point. Lets call this the capture rule.</li> <li>The capture applies for red agents too. If a red agent reaches any blue agents' starting position, red team will get a point.</li> <li>On a capture, the agent will be reset to its starting position.</li> <li>On every capture, the maximum number of steps will be increased by 10 steps (added to 120 with a cap of 1000).</li> <li>Maximum point team wins.</li> </ol> game.py<pre><code>def termination_rule(ctx):\n    if step_counter &gt;= max_steps or step_counter &gt;= config.MAX_SIM_STEPS:\n        ctx.terminate()\n</code></pre> <p>The above rule is a simple termination rule we can use to implement the conditioned termination criteria. We have <code>max_steps</code> as a global variable which we can set to 120 at the start of the simulation. The <code>termination_rule</code> function checks if the step counter is greater than or equal to the maximum number of steps or the maximum simulation steps. We can add <code>MAX_SIM_STEPS</code> to the <code>config.py</code> file and set it to 1000. The <code>termination_rule</code> function will be called in the main loop to check if the simulation should be terminated.</p> config.py<pre><code>MAX_SIM_STEPS = 1000 # NUMBER OF STEPS IN THE SIMULATION\n</code></pre> <p>To write the tag rule, we need to check if two agents from opposite teams are on the same node. We have the team in <code>meta</code> attribute in agent configuration.</p> game.py<pre><code>red_team = [name for name in config.agent_config if config.agent_config[name]['meta']['team'] == 0]\nblue_team = [name for name in config.agent_config if config.agent_config[name]['meta']['team'] == 1]\nred_start_dict = {name: config.agent_config[name]['start_node_id'] for name in red_team}\nblue_start_dict = {name: config.agent_config[name]['start_node_id'] for name in blue_team}\n\ndef tag_rule(ctx):\n    for red_agent in red_team:\n        for blue_agent in blue_team:\n            ragent = ctx.agent.get_agent(red_agent)\n            bagent = ctx.agent.get_agent(blue_agent)\n            if ragent.current_node_id == bagent.current_node_id:\n                # Reset the agents to their starting positions\n                ragent.current_node_id = red_start_dict[red_agent]\n                bagent.current_node_id = blue_start_dict[blue_agent]\n                ragent.prev_node_id = red_start_dict[red_agent]\n                bagent.prev_node_id = blue_start_dict[blue_agent]\n</code></pre> <p>The <code>tag_rule</code> function checks if two agents from opposite teams are on the same node. If they are, the agents are reset to their starting positions. The starting positions are stored in the <code>red_start_dict</code> and <code>blue_start_dict</code> dictionaries. The <code>current_node_id</code> attribute of the agent is used to get the current position of the agent. The <code>current_node_id</code> attribute is updated to the starting position of the agent. The <code>prev_node_id</code> attribute is used to store the previous position of the agent. We also reset it as we are completely resetting the agent to its starting condition.</p> <p>The <code>capture_rule</code> function is similar to the <code>tag_rule</code> function. It checks if a blue agent reaches any red agents' starting position. If it does, the blue team gets a point. The same applies for red agents too. The <code>capture_rule</code> function looks like this:</p> game.py<pre><code>red_team_score = 0\nblue_team_score = 0\nmax_steps = 120\n\ndef capture_rule(ctx):\n    global max_steps\n    global red_team_score\n    global blue_team_score\n    for red_agent in red_team:\n        agent = ctx.agent.get_agent(red_agent)\n        for val in blue_start_dict.values():\n            if agent.current_node_id == val:\n                # Red team gets a point\n                red_team_score += 1\n                # Reset the agent to its starting position\n                agent.current_node_id = red_start_dict[red_agent]\n                agent.prev_node_id = red_start_dict[red_agent]\n                max_steps += 10\n\n    for blue_agent in blue_team:\n        agent = ctx.agent.get_agent(blue_agent)\n        for val in red_start_dict.values():\n            if agent.current_node_id == val:\n                # Blue team gets a point\n                blue_team_score += 1\n                # Reset the agent to its starting position\n                agent.current_node_id = blue_start_dict[blue_agent]\n                agent.prev_node_id = blue_start_dict[blue_agent]\n                max_steps += 10\n</code></pre> <p></p> <p>Gameplay showing the tag and capture rules in action</p> <p>The <code>capture_rule</code> function checks if a blue agent reaches any red agents' starting position. If it does, the blue team gets a point. The same applies for red agents too. We are updating the <code>red_team_score</code> and <code>blue_team_score</code> variables to keep track of the score. The <code>max_steps</code> variable is updated to increase the maximum number of steps by 10 on every capture from either team.</p> <p>Let's put it all in the <code>game.py</code> file and  update the main loop to call the rules.</p> game.py<pre><code>import gamms\nimport config\n\n# ...\n\ncreate_grid(graph, config.GRID_SIZE)\n\n# ...\n\nred_team = [name for name in config.agent_config if config.agent_config[name]['meta']['team'] == 0]\nblue_team = [name for name in config.agent_config if config.agent_config[name]['meta']['team'] == 1]\n\n# ...\n\ndef termination_rule(ctx):\n    if step_counter &gt;= max_steps or step_counter &gt;= config.MAX_SIM_STEPS:\n        ctx.terminate()\n\n# ...\nstep_counter = 0 # initialize the step counter to 0\nwhile not ctx.is_terminated(): # run the loop until the context is terminated\n    step_counter += 1 # increment the step counter by 1\n    for agent in ctx.agent.create_iter():\n        # Get the current state of the agent\n        state = agent.get_state() # get the state of the agent\n        # Get human input to move the agent\n        node = ctx.visual.human_input(agent.name, state)\n        state['action'] = node\n        agent.set_state() # set the state of the agent\n\n\n    ctx.visual.simulate() # Draw loop for the visual engine\n    capture_rule(ctx) # check capture rule\n    tag_rule(ctx) # check tag rule\n    termination_rule(ctx) # check termination rule\n</code></pre> <p>The rules are called after the agent state updates. Note how the capture rule is called before the tag rule. The game rules are actually ambiguous here. Do we first resolve the tag rule and then the capture rule or vice versa? The way we have implemented it, the capture rule is called first and then the tag rule. The example also highlights that the order of rule resolution is important and writing it in this way allows to figure out ambiguities in the rules.</p> <p>Final changes in the files can be found in snippets/creating_rules</p>"},{"location":"tutorials/realistic_scenario/","title":"Converting to Realistic Scenarios","text":"<p>In the previous tutorial, we created a simple grid world with both teams controlled by the user. In this tutorial, we will see how to go to more realistic graphs that are modelled after real world road networks. Our goal will be to create an autonomous strategy for the agents to move arouund. In place of the agents being able to see the entire graph, we will add other sensors that allow the agent to get partial information about the environment, and then use that information to make decisions.</p>"},{"location":"tutorials/realistic_scenario/#loading-osm-graphs","title":"Loading OSM Graphs","text":"<p>GAMMS provides a way to load Open Street Map (OSM) road networks as graphs. OSM is a collaborative mapping project that provides free geographic data and mapping to anyone who wants to use it. Let us update the example we created in the previous tutorial to load an OSM graph. GAMMS provides two ways to load OSM graphs. The first way is to use the <code>gamms.osm.create_osm_graph</code> method which allows to build a graph directly by just inputting the location in the form of a string. Note that it relies on the boundary definitions created on Open Street Map. The second way is to use the <code>gamms.osm.graph_from_xml</code> method which allows to load a graph from an OSM XML file. The XML file can be downloaded from the OSM website. We will use the La_Jolla.osm file which is a small part of the neighborhood of La Jolla in San Diego, California near UC San Diego campus. Place it in the <code>gammstutorial</code> directory.</p> <p>To use the OSM utility, you need to install the <code>osmnx</code> library and do <code>import gamms.osm</code></p> config.py<pre><code>XML_FILE = 'La_Jolla.osm' # OSM XML file\nRESOLUTION = 100.0 # resolution of the graph in meters\nTOLERANCE = 0.01 # tolerance for the graph in meters\nBIDIRECTIONAL = False # whether the graph is bidirectional or not\n</code></pre> game.py<pre><code>G = gamms.osm.graph_from_xml(config.XML_FILE, resolution=config.RESOLUTION, tolerance=config.TOLERANCE, bidirectional=config.BIDIRECTIONAL)\nctx.graph.attach_networkx_graph(G) # attach the graph to the context\n</code></pre> <p> The La Jolla OSM graph loaded in GAMMS showing road networks as nodes and edges</p> <p>The <code>graph_from_xml</code> method takes the XML file as an argument and returns a graph object. The <code>attach_networkx_graph</code> method attaches the graph to the context. The <code>resolution</code> parameter is the resolution of the graph that GAMMS will try to space the nodes in the final graph. The <code>tolerance</code> parameter defines that details smaller than this will be ignored. The <code>bidirectional</code> parameter defines whether the graph should add extra edges to make all edges bidirectional which is <code>True</code> by default.  It takes some time to process the raw OSM data and create the intermediate <code>networkx</code> graph. For repeated testing, it is better to save the created networkx graph to a file and load it directly using the <code>networkx</code> library. It is also possible to create OSM graphs directly using a GUI program like JOSM. The program allows to create OSM graphs and save them as XML files which can be used in GAMMS, thus allowing to create custom graphs manually without relying on the programatic interface we used in the previos tutorial.</p> <p>You will observe that the agents are thrown in random locations in the graph as we are using the start position of the agents in the previous tutorial. Let us update the start positions to be randomized on the graph. In addition, let us add a few new rules to the game where there is range around any agent's start position which defines <code>team territory</code>. If the tag rule is triggered in a territory, the team in whose territory the tag rule is triggered will get a point. Furthermore, only the opposite team agent will be reset to the starting position. The <code>max_steps</code> will also increase. Let us parametrize everything in the <code>config.py</code> file.</p> config.py<pre><code>MAX_SIM_STEPS = 10000 # NUMBER OF STEPS IN THE SIMULATION\nTERRITORY_RADIUS = 500.0 # radius of the territory in meters\nSTEP_INCREMENT = 100 # increment for the simulation steps\nMIN_SIM_STEPS = 5000 # minimum number of steps in the simulation\n</code></pre> <p>We have added a new parameter <code>TERRITORY_RADIUS</code> which defines the radius of the territory in meters. The <code>STEP_INCREMENT</code> parameter defines the increment for the simulation steps. The <code>MIN_SIM_STEPS</code> parameter defines the minimum number of steps in the simulation. The <code>MAX_SIM_STEPS</code> parameter is set to 10000 to allow for a longer simulation time. The other changes update the termination criteria to be configurable.</p> config.py<pre><code>agent_config = {}\n\nfor i in range(RED_TEAM_AGENTS):\n    agent_config[f'agent_{i}'] = {\n        'meta': {'team': 0}, # team of the agent\n        'sensors': [f'neigh_{i}'], # sensors of the agent\n    }\n\nfor i in range(RED_TEAM_AGENTS, RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    agent_config[f'agent_{i}'] = {\n        'meta': {'team': 1}, # team of the agent\n        'sensors': [f'neigh_{i}'], # sensors of the agent\n    }\n</code></pre> <p>The territory will be a circle around the starting position of the agent with the radius defined by the <code>TERRITORY_RADIUS</code> parameter. The starting position of the agent is removed as we want to randomize it.</p> game.py<pre><code>import gamms, gamms.osm\nimport config\n\n# ...\n\nred_team = [name for name in config.agent_config if config.agent_config[name]['meta']['team'] == 0]\nblue_team = [name for name in config.agent_config if config.agent_config[name]['meta']['team'] == 1]\n\n# Start position of the agents\nnodes = ctx.graph.graph.nodes\nnode_keys = list(nodes.keys())\nblue_territory = set()\nred_territory = set()\nfor name in red_team:\n    start_node = random.choice(node_keys)\n    config.agent_config[name]['start_node_id'] = start_node\n    node_keys.remove(start_node)\n    removes = set()\n    for node_id in node_keys:\n        if (nodes[start_node].x - nodes[node_id].x)**2 + (nodes[start_node].y - nodes[node_id].y)**2 &lt; config.TERRITORY_RADIUS**2:\n            red_territory.add(node_id)\n            removes.add(node_id)\n\n    for node_id in removes:\n        node_keys.remove(node_id)\n\nfor name in blue_team:\n    start_node = random.choice(node_keys)\n    config.agent_config[name]['start_node_id'] = start_node\n    node_keys.remove(start_node)\n    removes = set()\n    for node_id in node_keys:\n        if (nodes[start_node].x - nodes[node_id].x)**2 + (nodes[start_node].y - nodes[node_id].y)**2 &lt; config.TERRITORY_RADIUS**2:\n            blue_territory.add(node_id)\n            removes.add(node_id)\n\n    for node_id in removes:\n        node_keys.remove(node_id)\n\nred_start_dict = {name: config.agent_config[name]['start_node_id'] for name in red_team}\nblue_start_dict = {name: config.agent_config[name]['start_node_id'] for name in blue_team}\n\n# Create all the agents\nfor name, agent in config.agent_config.items():\n    ctx.agent.create_agent(name, **agent)\n\n\n# Create all agents visualization\nfor name, vis_config in config.agent_vis_config.items():\n    ctx.visual.set_agent_visual(name, **vis_config)\n\nred_team_score = 0\nblue_team_score = 0\n\n# ...\n\nwhile not ctx.is_terminated(): # run the loop until the context is terminated\n    step_counter += 1 # increment the step counter by 1\n\n    # ...\n</code></pre> <p> Agents are randomly placed on the map within the highlighted territories</p> <p>We are choosing the start positions so as to avoid the case when two agents are too close to each other, especially the case when opposite team agents are too close as definition of territory will be ambiguous. We have updated the rules to reflect the new territory definition. There are no other major changes to the code.</p> <p>Final changed files at snippets/osm_graphs</p>"},{"location":"tutorials/realistic_scenario/#autonomous-agents","title":"Autonomous Agents","text":"<p>The agent object in GAMMS can register a strategy that it will execute to find the next node to move to. The strategy is any callable object like a function that takes the agent state as an argument. The call will update the state and add the <code>action</code> key to the state. Finally, the <code>set_state</code> method will do the actual update. The <code>register_strategy</code> method allows to register a strategy to the agent.</p> <p>The state of the agent is a dictionary that contains the current state of the agent. The base structure looks like:</p> <pre><code>state = {\n    'curr_pos': (integer), # The location id of the node where the agent is currently located\n    'sensor' : {\n        'sensor1': (Sensor 1 Type, Sensor 1 Data), # The data collected by sensor 1\n        'sensor2': (Sensor 2 Type, Sensor 2 Data), # The data collected by sensor 2\n        ...\n    }\n</code></pre> <p>We only have the <code>NeighborSensor</code> setup so far. We want the agent state to contain information about the opposite teams agents. Also, it will be good to get some more information about the environment as well. To do that, we will give each agent a sensor to get map information and agent information.</p> config.py<pre><code>sensor_config = {}\n\nfor i in range(RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    sensor_config[f'neigh_{i}'] = {\n        'type': gamms.sensor.SensorType.NEIGHBOR, # type of the sensor\n    }\n    sensor_config[f'map_{i}'] = {\n        'type': gamms.sensor.SensorType.ARC,\n        'sensor_range': 250, # range of the sensor\n        'fov': 1.0, # field of view of the sensor in radians\n    }\n    sensor_config[f'agent_{i}'] = {\n        'type': gamms.sensor.SensorType.AGENT_ARC,\n        'sensor_range': 250, # range of the sensor\n        'fov': 1.0, # field of view of the sensor in radians\n    }\n\nagent_config = {}\n\nfor i in range(RED_TEAM_AGENTS):\n    agent_config[f'agent_{i}'] = {\n        'meta': {'team': 0}, # team of the agent\n        'sensors': [f'neigh_{i}', f'map_{i}', f'agent_{i}'], # sensors of the agent\n    }\n\nfor i in range(RED_TEAM_AGENTS, RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    agent_config[f'agent_{i}'] = {\n        'meta': {'team': 1}, # team of the agent\n        'sensors': [f'neigh_{i}', f'map_{i}', f'agent_{i}'], # sensors of the agent\n    }\n</code></pre> <p>We have added the sensors under the name <code>map_{i}</code> and <code>agent_{i}</code>. The <code>map_{i}</code> sensor is an <code>ArcSensor</code> which gives the agent information about the environment in a circular area around the agent. The <code>sensor_range</code> parameter defines the range of the sensor in meters. The <code>fov</code> parameter defines the field of view of the sensor in radians. The <code>agent_{i}</code> sensor is an <code>AgentArcSensor</code> which gives the agent information about other agents in a circular area around the agent. The <code>sensor_range</code> and <code>fov</code> parameters are the same as for the <code>map_{i}</code> sensor.</p> <p> Agents with ArcSensor and AgentArcSensor showing the field of view and sensor range</p> <p>For the blue agents, we will make the file <code>blue_strategy.py</code> which will contain the strategy for the blue agents. Before writing out the strategy, let us first try to come up with a simple pseudo-algorithm. Let's say that:</p> <ol> <li>All the agents maintain a common shared map of the environment. This is same as same as saying complete information sharing or centralized control.</li> <li>All the agents update information about opposite team agents in the map that they can see.</li> <li>We use a simple potential approach. Every opposite team agent in their own territory have a negative potential proportional to the inverse L2 distance.</li> <li>Every opposite team agent in its own territory have a positive potential proportional to the inverse L2 distance.</li> <li>Every capturable node has a positive potential proportional to the inverse L2 distance.</li> <li>The agent will move to the node closest in direction of the force created by the potential field.</li> </ol> <p>With the above pseudo-algorithm in mind, let us write the strategy for the blue agents. The strategy will be in the <code>blue_strategy.py</code> file. The strategy will look like this:</p> blue_strategy.py<pre><code>import random\n\nnodes = {}\n\ncurrent_opposite_agents = {}\ncapturable_nodes = set()\nself_territory = set()\nopposite_territory = set()\n\nteam_names = set()\n\nclass Agent:\n    def __init__(self, name):\n        self.name = name\n        self._idx = int(name.split('_')[1])\n\n    def strategy(self, state):\n        # Get the current position of the agent\n        curr_pos = state['curr_pos']\n        # Get the sensor data\n        sensor_data = state['sensor']\n        # Get the map sensor data\n        map_sensor_data = sensor_data[f'map_{self._idx}'][1]\n        # Get the agent sensor data\n        agent_sensor_data = sensor_data[f'agent_{self._idx}'][1]\n\n        # Update the nodes\n        nodes.update(map_sensor_data['nodes'])\n        # Convert curr_pos to node\n        curr_pos = nodes[curr_pos]\n        # Update the current opposite agents\n        current_opposite_agents.update(\n            {name: pos for name, pos in agent_sensor_data.items() if name not in team_names}\n        )\n\n        force = [0.0, 0.0] # initialize the force to 0\n        # Calculate the force from capturable nodes\n        for node_id in capturable_nodes:\n            if node_id in nodes:\n                node = nodes[node_id]\n                dist = (node.x - curr_pos.x)**2 + (node.y - curr_pos.y)**2\n                dist = dist/(random.random() + 1e-6)\n                if dist &lt; 1e-6:\n                    continue\n                force[0] += (node.x - curr_pos.x) / dist\n                force[1] += (node.y - curr_pos.y) / dist\n\n        # Calculate the force from opposite team agents\n        for name, pos in current_opposite_agents.items():\n            if pos in opposite_territory:\n                if pos not in nodes:\n                    continue\n                node = nodes[pos]\n                dist = (node.x - curr_pos.x)**2 + (node.y - curr_pos.y)**2\n                if dist &lt; 1e-6:\n                    continue\n                force[0] -= (node.x - curr_pos.x) / dist * (random.random() + 1e-6)\n                force[1] -= (node.y - curr_pos.y) / dist * (random.random() + 1e-6)\n            if pos in self_territory:\n                if pos not in nodes:\n                    continue\n                node = nodes[pos]\n                dist = (node.x - curr_pos.x)**2 + (node.y - curr_pos.y)**2\n                if dist &lt; 1e-6:\n                    continue\n                force[0] += (node.x - curr_pos.x) / dist * (random.random() + 1e-6)\n                force[1] += (node.y - curr_pos.y) / dist * (random.random() + 1e-6)\n\n        neighbors = sensor_data[f'neigh_{self._idx}'][1]\n\n        neighbor_nodes = [nodes[neighbor] for neighbor in neighbors if neighbor in nodes]\n\n        dot_products = {}\n\n        # Calculate the force dot product\n        for node in neighbor_nodes:\n            dot_product = (node.x - curr_pos.x) * force[0] + (node.y - curr_pos.y) * force[1]\n            dot_products[node.id] = dot_product + (0.5 - random.random()) * 0.1\n\n        # Return the node with the maximum dot product\n        max_node = max(dot_products, key=dot_products.get)\n        state['action'] = max_node\n\n\n# Mapper called by game to register the agents\ndef mapper(agent_names, territory, oterritory, capturables):\n    ret = {}\n    for name in agent_names:\n        team_names.add(name)\n        agent = Agent(name)\n        ret[name] = agent.strategy\n\n    nodes.update(capturables)\n\n    self_territory.update(territory)\n    opposite_territory.update(oterritory)\n    capturable_nodes.update(set(capturables.keys()))\n    return ret\n</code></pre> <p>The <code>mapper</code> function is called by the game to register the agents. The <code>territory</code> and <code>oterritory</code> parameters are the territories of the team and opposite team respectively. The <code>capturables</code> parameter is the set of capturable nodes. The <code>mapper</code> function returns a dictionary of agent names and their strategies. We will have to change <code>game.py</code> to register the strategies to the agents from the dictionary returned by the <code>mapper</code> function. For the red agents, we will use the same strategy. Copy the <code>blue_strategy.py</code> file to <code>red_strategy.py</code>. No changes are needed to the code as both cases are completely symmetric.</p> <p>Let us now update the <code>game.py</code> file to register the strategies. We will have to update the registration part as well as the main loop to use the agent strategies and not the human input. The registration part will look like this:</p> game.py<pre><code>strategies = blue_strategy.mapper(\n    blue_team,\n    blue_territory,\n    red_territory,\n    {node: ctx.graph.graph.get_node(node) for node in list(red_start_dict.values())},\n)\n\nfor name, strategy in strategies.items():\n    ctx.agent.get_agent(name).register_strategy(strategy)\n\nstrategies = red_strategy.mapper(\n    red_team,\n    red_territory,\n    blue_territory,\n    {node: ctx.graph.graph.get_node(node) for node in list(blue_start_dict.values())},\n)\n\nfor name, strategy in strategies.items():\n    ctx.agent.get_agent(name).register_strategy(strategy)\n\ndel strategies\n</code></pre> <p>In the main loop, we will first collect all agent states, populate the action in the state and then set it.</p> game.py<pre><code>while not ctx.is_terminated(): # run the loop until the context is terminated\n    step_counter += 1 # increment the step counter by 1\n    state_dict = {}\n    for agent in ctx.agent.create_iter():\n        # Get the current state of the agent\n        state = agent.get_state() # get the state of the agent\n        state_dict[agent.name] = state\n\n    for agent in ctx.agent.create_iter():\n        agent.strategy(state_dict[agent.name]) # call the strategy function of the agent\n\n    for agent in ctx.agent.create_iter():\n        agent.set_state() # set the state of the agent    \n\n    ctx.visual.simulate() # Draw loop for the visual engine\n    capture_rule(ctx) # check capture rule\n    tag_rule(ctx) # check tag rule\n    termination_rule(ctx) # check termination rule\n</code></pre> <p></p> <p>Autonomous agents moving according to their strategy, showing decision-making in action</p> <p>Note how the strategy function is called one after the other. It also means that the strategy of individual agents will not receive all the data from all agents as the data has not arrived yet. The strategy is implicity sequential. One way to solve this is to do the individual calls using threads and do internal synchronization on agent side. We are not going to implement that here as there are multiple ways to do that. There are also other ways where strategy is called multiple before setting the states to ensure that all data is available. Multiple calls will recalculate the action and replace the initial action without ever executing it.</p> <p>The agent will mostly play a waiting game and will do some random movement to test the response of the opposite team. The heuristic is not very good but it is a start. The agents will be able to move around the graph and capture nodes. We can see the entire graph and the agents moving around but the agents can only see a small part of the graph. The next part is to visualize what the agents see. We can easily do this by setting up the a visual config for each sensor.</p> config.py<pre><code>sensor_vis_config = {}\n\nfor i in range(RED_TEAM_AGENTS + BLUE_TEAM_AGENTS):\n    sensor_vis_config[f'neigh_{i}'] = {\n        'color': (255, 255, 0), # color of the sensor\n        'size': 2,\n        'layer': 25,\n    }\n    sensor_vis_config[f'map_{i}'] = {\n        'node_color': (0, 255, 0), # color of the sensor\n        'edge_color': (0, 255, 0), # color of the sensor\n        'size': 2,\n        'layer': 24, # Plot below neighbors\n    }\n    sensor_vis_config[f'agent_{i}'] = {\n        'color': (0, 0, 255), # color of the sensor\n        'size': 8,\n        'layer': 31, # Plot above everything\n    }\n</code></pre> <p>The <code>sensor_vis_config</code> dictionary contains the visualization configuration for each sensor. The <code>color</code> parameter defines what color to use for drawing the sensor data. The layer defines the overlay order for each drawing. When things are in same layer, there is no fixed order in which anything is drawn. In <code>game.py</code>, we need to set the configuration using the <code>set_sensor_visual</code> method. The code will look like this:</p> game.py<pre><code># Create all the sensors visualization\nfor name, sensor_config in config.sensor_vis_config.items():\n    ctx.visual.set_sensor_visual(name, **sensor_config)\n</code></pre> <p> Visualization of sensor data showing what each agent can see, with the visible area highlighted</p> <p>When you run the code, you will see green lines highlighing the area detected by the <code>map</code> sensors. It might be hard to see, but an overlay is created on an agent when it comes in the range of <code>agent</code> sensors.</p> <p>Final changed files at snippets/autonomous_agents</p>"},{"location":"tutorials/realistic_scenario/#understanding-artists","title":"Understanding Artists","text":"<p>In the game, we are able to see the output of the sensors. But we are lacking the visual feedback for where the capturable nodes and territories of the teams are. Both capturable nodes and territories are specific to the scenario we are creating and hence we want to define a custom drawing for visualizing these details.</p> <p>GAMMS visual system relies on <code>Artists</code> to draw everything on the screen. The artists are containers that hold the data required for drawing and a recepie to draw something using the data. Let us first try to create a custom artist which will draw rectangles of the color of the team on the capturable nodes.</p> game.py<pre><code># Capturable nodes artist\ndef draw_capturable_nodes(ctx, data):\n    width = data.get('width', 10)\n    height = data.get('height', 10)\n    for node_id in data['red']:\n        node = ctx.graph.graph.get_node(node_id)\n        ctx.visual.render_rectangle(node.x, node.y, width, height, color=(255, 0, 0))\n\n    for node_id in data['blue']:\n        node = ctx.graph.graph.get_node(node_id)\n        ctx.visual.render_rectangle(node.x, node.y, width, height, color=(0, 0, 255))\n\n\ncapturable_artist = gamms.visual.Artist(\n    ctx,\n    drawer = draw_capturable_nodes,\n    layer = 39,\n)\ncapturable_artist.data['red'] = list(red_start_dict.values())\ncapturable_artist.data['blue'] = list(blue_start_dict.values())\nctx.visual.add_artist('capturable_artist', capturable_artist)\n</code></pre> <p>The <code>draw_capturable_nodes</code> function is the drawing function that will be called by the artist. The <code>data</code> parameter contains the data that is passed to the artist. The <code>width</code> and <code>height</code> parameters are the width and height of the rectangle to be drawn. We choose the layer to be 39 so that it is above most of the other drawings. By default, all artists draw at layer 30. Graph is drawn at layer 10, agents on layer 20, and the sensors default to layer 30. Every <code>set_*something*_visual</code> returns an artist object and gives full control to the user if required. The visual engine provides methods like <code>render_rectangle</code>, <code>render_circle</code>, <code>render_line</code>, etc. to draw basic shapes. As you can see, in a single artist it is possible to draw multiple shapes. The <code>render_rectangle</code> method takes the x and y coordinates of the center of the rectangle, and the width, height and color of the rectangle.</p> <p> Custom artist visualization showing capturable nodes marked with colored rectangles</p> <p>It is possible to turn on-off any of the artists by using the <code>artist.set_visible</code> method. What we will try to do is alternately turn the artists on and off for individual teams. Every 10 turns, we will switch which team is visible. The easiest way to do this is to populate the artists in two groups and then use the <code>set_visible</code> method to turn them on and off. In our implementation until now, we have ignored the outputs from the <code>set_*something*_visual</code> methods. The artists are created and added to the context but we do not keep a reference to them. Let's look at the various changes one by one.</p> game.py<pre><code># artist groups\nred_artist_list = []\nblue_artist_list = []\n\n# Create all the sensors\nfor name, sensor in config.sensor_config.items():\n    ctx.sensor.create_sensor(name, sensor['type'], **sensor)\n\n# Create all the sensors visualization\nfor name, sensor_config in config.sensor_vis_config.items():\n    artist = ctx.visual.set_sensor_visual(name, **sensor_config)\n    if int(name.split('_')[1]) &lt; config.RED_TEAM_AGENTS:\n        red_artist_list.append(artist)\n    else:\n        blue_artist_list.append(artist)\n</code></pre> <p>We create two lists <code>red_artist_list</code> and <code>blue_artist_list</code> to hold the artists for each team. When setting up the sensor visual, we are taking the artist object returned by the <code>set_sensor_visual</code> method and adding it to the respective list. We do the same for the agent visualizations.</p> game.py<pre><code># Create all agents visualization\nfor name, vis_config in config.agent_vis_config.items():\n    artist = ctx.visual.set_agent_visual(name, **vis_config)\n    if int(name.split('_')[1]) &lt; config.RED_TEAM_AGENTS:\n        red_artist_list.append(artist)\n    else:\n        blue_artist_list.append(artist)\n</code></pre> <p>Now we need to add the switch on and off logic to the main loop. We will do this by using a counter to keep track of the number of steps. Every 10 steps, we will switch the artists on and off. The code will look like this:</p> game.py<pre><code>while not ctx.is_terminated(): # run the loop until the context is terminated\n    artist_bool = (step_counter // 10) % 2 == 0 # check if the step counter is even\n\n    if artist_bool:\n        on_group = red_artist_list\n        off_group = blue_artist_list\n    else:\n        on_group = blue_artist_list\n        off_group = red_artist_list\n\n    for artist in on_group:\n        artist.set_visible(True)\n    for artist in off_group:\n        artist.set_visible(False)\n\n    step_counter += 1 # increment the step counter by 1\n    state_dict = {}\n    for agent in ctx.agent.create_iter():\n        # Get the current state of the agent\n        state = agent.get_state() # get the state of the agent\n        state_dict[agent.name] = state\n\n    for agent in ctx.agent.create_iter():\n        agent.strategy(state_dict[agent.name]) # call the strategy function of the agent\n\n    for agent in ctx.agent.create_iter():\n        agent.set_state() # set the state of the agent    \n\n    ctx.visual.simulate() # Draw loop for the visual engine\n    capture_rule(ctx) # check capture rule\n    tag_rule(ctx) # check tag rule\n    termination_rule(ctx) # check termination rule\n</code></pre> <p> Demonstration of toggling visibility between red and blue team artists every 10 steps</p> <p>The <code>artist_bool</code> variable is used to check if the step counter is even or odd. If it is even, we turn on the red artists and turn off the blue artists. If it is odd, we turn on the blue artists and turn off the red artists.</p> <p>Final changed files at snippets/understanding_artists</p>"},{"location":"tutorials/replay_analysis/","title":"Final Touches &amp; Analysis Tools","text":"<p>In the previous tutorial, we have created a complete game with autonomous agents. However, we have not addressed the issue of getting custom information in the agent state that might depend on the scenario. Furthermore, it will be good to store a simulation and replay it without having to do all the calculations again. In this tutorial, we will try to address these issues and explore many of the functionalities of GAMMS that we have not used so far.</p>"},{"location":"tutorials/replay_analysis/#custom-sensors","title":"Custom Sensors","text":"<p>In the scenario that we have constructed, the agents already have information about where the capturable nodes are and what nodes are in the territories of both teams. To make it more realistic, it will be better that the agents can sense this information and make decisions based on how much exploration they have done. We will create two sensors; one for capturable nodes and one for the territory. After that, we will also see how to visualize the outputs from the new sensors in the game.</p> <p>To create a custom sensor, we need to inherit <code>gamms.typing.ISensor</code> which defines the interface for sensors.</p> game.py<pre><code>@ctx.sensor.custom(name=\"CAPTURE\")\nclass CapturableSensor(gamms.typing.ISensor):\n    def __init__(self, ctx, sensor_id, capturable_nodes, range: float = 160.0):\n        self.ctx = ctx\n        self.capturable_nodes = capturable_nodes\n        self._data = {}\n        self._sensor_id = sensor_id\n        self._range = range\n        self._owner = None\n\n    def set_owner(self, owner):\n        self._owner = owner\n\n    @property\n    def type(self):\n        return gamms.sensor.SensorType.CUSTOM\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def sensor_id(self):\n        return self._sensor_id\n\n    def sense(self, node_id):\n        node = self.ctx.graph.graph.get_node(node_id)\n        self._data.clear()\n        for cnode_id in self.capturable_nodes:\n            capturable_node = self.ctx.graph.graph.get_node(cnode_id)\n            dist = (node.x - capturable_node.x)**2 + (node.y - capturable_node.y)**2\n            if dist &lt; self._range**2:\n                self._data[cnode_id] = dist**0.5\n\n\n    def update(self, data):\n        return\n</code></pre> <p>There are multiple methods that are necessary to be defined for a custom sensor to work. All the 5 methods defined are required methods, and if not defined, GAMMS will throw an error when instantiating the sensor. In addition, we have a decorator <code>@ctx.sensor.custom</code> which registers the sensor with the context. The wrapper does somethings behind the scenes and requires a <code>name</code> parameter. As such, there is a generic type custom for custom sensors, but ideally we would like to distinguish between different custom sensors. One of the things that the decorator does for you is extend the <code>SensorType</code> to have a <code>SensorType.CAPTURE</code> and the type of the capturable sensor will be returned as <code>SensorType.CAPTURE</code>. The <code>sense</code> method is called when the data is to be collected. The <code>update</code> method is something that can be used to create <code>active</code> sensors. We will not worry about the <code>update</code> method for now as our sensor just collects environment data. The <code>set_owner</code> method gets called by the agent when the sensor is registered to it. The agent will pass its name as the argument to the <code>set_owner</code> method. The <code>data</code> property is the data that is collected by the sensor and <code>sensor_id</code> is the unique id of the sensor.</p> <p>Let us remove the <code>capturable_artist</code> that we created previously and in-place modify the <code>draw_capturable_nodes</code> function to define the visualization for the new sensor. The new function will look like this:</p> game.py<pre><code># Capturable nodes artist\ndef draw_capturable_nodes(ctx, data):\n    width = data.get('width', 10)\n    height = data.get('height', 10)\n    sensor = ctx.sensor.get_sensor(data['sensor'])\n    color = data.get('color', (0, 0, 0))\n    if sensor is not None:\n        return\n    for node_id in sensor.data:\n        node = ctx.graph.graph.get_node(node_id)\n        ctx.visual.render_rectangle(node.x, node.y, width, height, color=color)\n</code></pre> <p>The <code>draw_capturable_nodes</code> function now takes an additional parameter <code>sensor</code> which is the sensor sensor_id from which the data can be obtained. We need to create an artist for each copy of <code>CAPTURE</code> sensor we create andd register them to the agents.</p> game.py<pre><code># Create capture sensors\nfor name in red_team:\n    sensor_id = f\"capture_{name}\"\n    sensor = CapturableSensor(ctx, sensor_id, list(blue_start_dict.values()), range=160.0)\n    ctx.sensor.add_sensor(sensor)\n    ctx.agent.get_agent(name).register_sensor(sensor_id, sensor)\n    artist = gamms.visual.Artist(\n        ctx,\n        drawer=draw_capturable_nodes,\n        layer=39,\n    )\n    artist.data['sensor'] = sensor.sensor_id\n    artist.data['width'] = 10.0\n    artist.data['height'] = 10.0\n    artist.data['color'] = (0, 0, 255)\n    ctx.visual.add_artist(sensor_id, artist)\n\nfor name in blue_team:\n    sensor_id = f\"capture_{name}\"\n    sensor = CapturableSensor(ctx, sensor_id, list(red_start_dict.values()), range=160.0)\n    ctx.sensor.add_sensor(sensor)\n    ctx.agent.get_agent(name).register_sensor(sensor_id, sensor)\n    artist = gamms.visual.Artist(\n        ctx,\n        drawer=draw_capturable_nodes,\n        layer=39,\n    )\n    artist.data['sensor'] = sensor.sensor_id\n    artist.data['width'] = 10.0\n    artist.data['height'] = 10.0\n    artist.data['color'] = (255, 0, 0)\n    ctx.visual.add_artist(sensor_id, artist)\n</code></pre> <p>We are creating the sensors with a range of 160 meters and defining the opposite team as the capturable nodes. The <code>draw_capturable_nodes</code> function will be called by the artist to draw the capturable nodes. The <code>color</code> parameter is set to the color of the opposite team so that the red team will see blue rectangles and the blue team will see red rectangles. Let's remove the artist grouping logic and the turn on/off logic as well. We are calling the <code>ctx.sensor.add_sensor</code> method to keep a reference to the sensor object in the context. The <code>ctx.agent.get_agent(name).register_sensor(sensor_id, sensor)</code> method registers the sensor to the agent.</p> <p>The <code>ctx.sensor.get_sensor</code> method used in the <code>draw_capturable_nodes</code> function will fail if the sensor is not registered in the context.</p> <p>Let us now add the territory sensor which will return the territory of both teams in the range of the sensor.</p> game.py<pre><code>@ctx.sensor.custom(name=\"TERRITORY\")\nclass TerritorySensor(gamms.typing.ISensor):\n    def __init__(self, ctx, sensor_id, red_nodes, blue_nodes, range: float = 160.0):\n        self.ctx = ctx\n        self.red_nodes = red_nodes\n        self.blue_nodes = blue_nodes\n        self._data = {'red': {}, 'blue': {}}\n        self._sensor_id = sensor_id\n        self._range = range\n        self._owner = None\n\n    def set_owner(self, owner):\n        self._owner = owner\n\n    @property\n    def type(self):\n        return gamms.sensor.SensorType.CUSTOM\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def sensor_id(self):\n        return self._sensor_id\n\n    def sense(self, node_id):\n        node = self.ctx.graph.graph.get_node(node_id)\n        self._data.clear()\n        self._data['red'] = {}\n        self._data['blue'] = {}\n        for cnode_id in self.red_nodes:\n            territory_node = self.ctx.graph.graph.get_node(cnode_id)\n            dist = (node.x - territory_node.x)**2 + (node.y - territory_node.y)**2\n            if dist &lt; self._range**2:\n                self._data['red'][cnode_id] = dist**0.5\n        for cnode_id in self.blue_nodes:\n            territory_node = self.ctx.graph.graph.get_node(cnode_id)\n            dist = (node.x - territory_node.x)**2 + (node.y - territory_node.y)**2\n            if dist &lt; self._range**2:\n                self._data['blue'][cnode_id] = dist**0.5\n\n    def update(self, data):\n        return\n</code></pre> <p>Let us also add the visualization for the territory sensor similar to what we did before.</p> game.py<pre><code># Territory nodes artist\ndef draw_territory_nodes(ctx, data):\n    size = data.get('size', 10)\n    sensor = ctx.sensor.get_sensor(data['sensor'])\n    for node_id in sensor.data['red']:\n        node = ctx.graph.graph.get_node(node_id)\n        ctx.visual.render_circle(node.x, node.y, size, color=(255, 0, 0))\n    for node_id in sensor.data['blue']:\n        node = ctx.graph.graph.get_node(node_id)\n        ctx.visual.render_circle(node.x, node.y, size, color=(0, 0, 255))\n</code></pre> <p>We are drawing circles for the territory nodes. The <code>size</code> parameter is the radius of the circle to be drawn. We will create the sensor and register it to the agents in a similar way as we did for the capturable sensor. After registering the sensors, we will see an overlay of red and blue nodes on the output of the <code>map</code> sensors showing the various territories.</p> game.py<pre><code># Create territory sensors\nfor name in red_team:\n    sensor_id = f\"territory_{name}\"\n    sensor = TerritorySensor(ctx, sensor_id, list(red_territory), list(blue_territory), range=160.0)\n    ctx.sensor.add_sensor(sensor)\n    ctx.agent.get_agent(name).register_sensor(sensor_id, sensor)\n    artist = gamms.visual.Artist(\n        ctx,\n        drawer=draw_territory_nodes,\n        layer=39,\n    )\n    artist.data['sensor'] = sensor.sensor_id\n    artist.data['size'] = 10.0\n    ctx.visual.add_artist(sensor_id, artist)\n\nfor name in blue_team:\n    sensor_id = f\"territory_{name}\"\n    sensor = TerritorySensor(ctx, sensor_id, list(blue_territory), list(red_territory), range=160.0)\n    ctx.sensor.add_sensor(sensor)\n    ctx.agent.get_agent(name).register_sensor(sensor_id, sensor)\n    artist = gamms.visual.Artist(\n        ctx,\n        drawer=draw_territory_nodes,\n        layer=39,\n    )\n    artist.data['sensor'] = sensor.sensor_id\n    artist.data['size'] = 10.0\n    ctx.visual.add_artist(sensor_id, artist)\n</code></pre> <p> Visualization of territories detected by the territory sensor, displayed as colored circles</p> <p>Now that we have the input from these sensors, we can remove the hard coded territory and capturable nodes from the agent state. The agent will now be able to figure out the information about the territory and capturable nodes from the sensors. Let's look at the changes to the <code>blue_strategy.py</code> file.</p> blue_strategy.py<pre><code>        capture_sensor_data = sensor_data[f'capture_{self.name}'][1]\n        # Get the territory sensor data\n        territory_sensor_data = sensor_data[f'territory_{self.name}'][1]\n\n        for node_id in capture_sensor_data:\n            capturable_nodes.add(node_id)\n        for node_id in territory_sensor_data['blue']: # change according to the team\n            self_territory.add(node_id)\n        for node_id in territory_sensor_data['red']: # change according to the team\n            opposite_territory.add(node_id)\n</code></pre> <p>The <code>capture_sensor_data</code> and <code>territory_sensor_data</code> variables are the data collected by the sensors. The <code>self_territory</code> and <code>opposite_territory</code> variables are updated with the data from the sensors. The <code>capturable_nodes</code> variable is updated with the data from the <code>capture_sensor_data</code>. We remove the arguments from the <code>mapper</code> function as we are not using them anymore. The <code>mapper</code> function will look like this:</p> blue_strategy.py<pre><code>def mapper(agent_names):\n    ret = {}\n    for name in agent_names:\n        team_names.add(name)\n        agent = Agent(name)\n        ret[name] = agent.strategy\n\n    return ret\n</code></pre> <p>We make similar changes to the <code>red_strategy.py</code> file where the only difference is that the <code>self_territory</code> and <code>opposite_territory</code> variables are swapped. We also remove the arguments passed to <code>mapper</code> in <code>game.py</code>.</p> <p>Final changed files at snippets/custom_sensors</p>"},{"location":"tutorials/replay_analysis/#recording-system","title":"Recording System","text":"<p>Until now, we have relied on the visual engine to show us the output of the simulation. But there is quite an overhead in visualizing everything . When we have human input, it makes sense to visualize things but when we have autonomous agents, we can run the simulation without any visualization and then replay the simulation. Furthermore, we need a way to record a simulation to replay it and do analysis on it. GAMMS provides a <code>Recorder</code> which allows you to record a simulation and then replay it. To record a game, we only need to start the recording and there is no need to change anything in the game file. To record a game, we will add the following lines to the <code>game.py</code> file:</p> game.py<pre><code># Record\nctx.record.start(path=\"recording\")\n</code></pre> <p>The <code>start</code> method takes a <code>path</code> parameter which is the path where the recording will be saved. The recording will be saved to <code>recording.ggr</code> as a binary file. The recorded files differentailly stores the data for each step. In the current version, the following events are recorded by default:</p> <ol> <li>Agent creation and deletion</li> <li>Agent position changes</li> <li>When a sensor is registered or deregistered from an agent</li> <li>Every time the control is given to the visual engine (Calls to <code>ctx.visual.simulate()</code>)</li> <li>When the game is terminated</li> </ol> <p>The recording will only start after the call to <code>ctx.record.start()</code> and will stop when the game is terminated. Anything before will not be recorded. There are also play, pasue and stop methods to control the recording process. The mmethod <code>ctx.record.record()</code> returns a True/False based on whether recording is in progress or not.</p> <p>To speed up the simulation, we can also turn off the visual engine. To do this, we will switch the visual engine to <code>NO_VIS</code>.</p> config.py<pre><code>VIS_ENGINE = gamms.visual.Engine.NO_VIS # visual engine to use\n</code></pre> <p>The game will run but as we are not visualizing anything, it is okay to remove all the artists related setups from the <code>game.py</code> file. It will not make any difference in the game speed but it will make the code cleaner and easier to read. Now we can create a file called replay.py which will contain the code to replay the simulation.</p> replay.py<pre><code>import gamms, gamms.osm\nimport config\n\nctx = gamms.create_context(\n    vis_engine=gamms.visual.Engine.PYGAME,\n    vis_kwargs={'simulation_time_constant': 0.3},\n    logger_config={'level': 'WARNING'},\n) # create a context with PYGAME as the visual engine\n\nG = gamms.osm.graph_from_xml(\n    config.XML_FILE,\n    resolution=config.RESOLUTION,\n    tolerance=config.TOLERANCE,\n    bidirectional=config.BIDIRECTIONAL\n)\nctx.graph.attach_networkx_graph(G) # attach the graph to the context\n\n# Create the graph visualization\n\ngraph_artist = ctx.visual.set_graph_visual(**config.graph_vis_config) # set the graph visualization with width 1980 and height 1080\n\n# Create all agents visualization\nfor name, vis_config in config.agent_vis_config.items():\n    artist = ctx.visual.set_agent_visual(name, **vis_config)\n\nfor _ in ctx.record.replay(\"recording\"):\n    continue\n\nctx.terminate() # terminate the context\n</code></pre> <p>We are setting up the visualizations for the graph and the agents and then playing the recording. The <code>ctx.record.replay</code> method takes the path to the recording file and returns a generator which yields the events in the recording. We are not doing anything for now but internally the event is yeilded after executing the event. We will look into details of the replay system in the next section. We pass the <code>simulation_time_constant</code> parameter to the visual engine to control the speed of the simulation. Here, we are speeding it up to 0.3 seconds instead of the deafult 2 seconds. The logger level sets the level of logging to WARNING. The recorder will log all events on the deafult INFO level.</p> <p>Warnings will appear that the sensors are being ignored. This is because no sensors are defined. If the sensors are defined, the data will be populated during replay. Similarly, if a visualization for populated sensor data is defined, it will be drawn during replay.</p> <p>In the scenario we have created, it will be good if we can keep a track of the team scores and access them while replaying. To do this, we need to create a recorded component.</p> game.py<pre><code># Create recorded component\n@ctx.record.component(struct={\n    'step': int,\n    'max_steps': int,\n    'red_tag_score': int,\n    'blue_tag_score': int,\n    'red_capture_score': int,\n    'blue_capture_score': int,\n    }\n)\nclass ReportCard:\n    def __init__(self):\n        self.step = 0\n        self.max_steps = config.MIN_SIM_STEPS\n        self.red_tag_score = 0\n        self.blue_tag_score = 0\n        self.red_capture_score = 0\n        self.blue_capture_score = 0\n\n\nreport_card = ReportCard(name=\"report_card\")\n</code></pre> <p>The <code>ReportCard</code> class is a recorded component which will be used to keep track of the scores. The <code>struct</code> parameter is a dictionary which defines the structure of the component. The <code>step</code> and <code>max_steps</code> parameters are used to keep track of the current step and the maximum number of steps. We have split the scores into <code>tag_score</code> and <code>capture_score</code> for both teams. The <code>ctx.record.component</code> decorator registers the component type with the context. The <code>name</code> parameter is directly added by the decorator and it is required to be passed when creating the component. The <code>name</code> needs to be unique for each component.</p> <p>The keyword <code>name</code> is reserved and should not be used as a variable in the component. Other internal parameters can be created as a normal object but only the ones mentioned in the <code>struct</code> will be recorded. The type of all the parameters in the <code>struct</code> should be json serializable -- Type definition: <code>JsonType = Union[None, int, str, bool, List[\"JsonType\"], Dict[str, \"JsonType\"]]</code></p> <p>We can replace all the different score variables with a reference to the <code>report_card</code> object and update the scores in the <code>capture_rule</code> and <code>tag_rule</code> functions. We also need to update the counter updates and in the main loop. The <code>step_counter</code> variable is now replaced with <code>report_card.step</code> and the <code>max_steps</code> variable is replaced with <code>report_card.max_steps</code>.</p> <p>Final changed files at snippets/recording_system</p>"},{"location":"tutorials/replay_analysis/#replay-analysis","title":"Replay Analysis","text":"<p>Under Construction</p>"}]}